Introduction

    Most of today’s APIs have a big problem: once deployed, they can’t change. There are
    big-name APIs that stay static for years at a time, as the industry changes around them,
    because changing them would be too difficult.

    A very simple system is always easy to change. At small scales, a RESTful system has a
    larger up-front design cost than a push-button solution. But as your API matures and
    starts to change, you’ll really need some way—like REST—of adapting to change.

    But my main
    goal is to teach you the underlying principles of REST. Learn those, and you’ll be able
    to exploit whichever experiments pan out and whichever standards are approved.

    There are two specific problems I’m trying to solve with this book: duplication of effort
    and avoidance of hypermedia. Let’s take a look at them.

    Duplication of Effort

        Of course, Twitter, Facebook, and Google are big companies that compete with each
        other. They don’t want to make it easy for you to learn their competitors’ APIs. But small
!!!!    companies and nonprofits do the same thing. They design their APIs as though nobody
        else had ever had a similar idea. This interferes with their goal of getting people to
        actually use their APIs.

        Let me show you just one example. The website ProgrammableWeb has a directory of
        over 8,000 APIs. As I write this, it knows about 57 microblogging APIs—APIs whose
        main purpose is posting a little bit of text to a user account.
        It’s great that there are 57
        companies publishing APIs in this field, but do we really need 57 different designs? We’re
        not talking about something complicated here, like insurance policies or regulatory
        compliance. We’re talking about posting a little bit of text to a user account. Do you
        want to be the one who designs the 58th microblogging API?

        There’s something about APIs that makes everyone want to design their own from scratch, even when that
        makes no sense from a business perspective.

    Hypermedia Is Hard
        But there’s one aspect of REST that most developers still don’t understand: hypermedia.
        We all understand hypermedia in the context of the Web. It’s just a fancy word for links.
        Web pages link to each other, and the result is the World Wide Web, driven by hyper‐
        media. But it seems we’ve got a mental block when it comes to hypermedia in web APIs.
        This is a big problem, because hypermedia is the feature that makes a web API capable
        of handling changes gracefully.

        I did it this way because hypermedia is the single most important aspect of REST, and
        the least understood.


    Understanding Standards
        The World Wide Web isn’t an objective thing that’s out there to be studied scientifically.
        It’s a social construct—a set of agreements to do things a certain way. Fortunately, unlike
        other social constructs (like etiquette), the agreements underlying the Web are generally
        agreed upon. The core agreements underlying the human web are RFC 2616 (the HTTP
        standard), the W3C’s specification for HTML 4, and ECMA-262 (the standard that
        underlies JavaScript, also known as ECMAScript). Each standard does a different job,
        and over the course of this book, I’ll discuss dozens of other standards designed specif‐
        ically for use in APIs

!!!!    When navigating the forest of standards, it’s useful to keep in mind that not all standards
        have equal force. Some are extremely well established, used by everyone, and if you go
        against them you’re causing a lot of trouble for yoursef. Other standards are just one
        person’s opinion, and that opinion might be no better than yours.
        I find it helpful to divide standards into four categories: fiat standards, personal stand‐
        ards, corporate standards, and open standards. I’ll be using these terms throughout the
        book, so let me explain each one in a bit more depth before we move on.

    Fiat Standards
        Fiat standards aren’t really standards; they’re behaviors. No one agreed to them. They’re
        just a description of the way somebody does things. The behavior may be documented,
        but the core assumption of a standard—that other people ought to do things the same
        way—is missing.
        Pretty much every API today is a fiat standard, a one-off design associated with a specific
        company. That’s why we talk about the “Twitter API,” the “Facebook API,” and the
        “Google+ API.”

        unless you work for the company in question, there’s no expectation that you should use this design for your
        API. If you reuse a fiat standard, we don’t say your API conforms to a standard; we say it’s a clone.

        The main problem I’m trying to solve in this book is that hundreds of person-years of
        design work is locked up in fiat standards where it can’t be reused. This needs to stop.
!!!!    Designing a new API today means reinventing a long series of wheels. Once your API
        is finished, your client developers have to reinvent corresponding wheels on the client side.
!!!!    Even under ideal circumstances, your API will be a fiat standard, since your business
        requirements will be slightly different from everyone else’s. But ideally a fiat standard
        would be just a light gloss over a number of other standards.

    Personal Standards
        Personal standards are standards—you’re invited to read the documents and implement
        the standards yourself—but they’re just one person’s opinion. The Maze+XML standard
        I describe in Chapter 5 is a good example. There’s no expectation that Maze+XML is
        the standard way to implement a maze game API, but if it works for you, you might as
        well use it. Someone else has done the design work for you

        Many open standards start off as personal standards—as side projects that are formal‐
        ized after a lot of experimentation. Siren, which I cover in Chapter 7, is a good example.

    Corporate Standards
        Corporate standards are created by a consortium of companies trying to solve a problem
        that plagues them all, or by a single company trying to solve a recurring problem on
        behalf of its customers. Corporate standards tend to be better defined and to use more
        formal language than personal standards, but they have no more force than personal
        standards. They’re just one company’s (or a group of companies') opinion

        Many industry standards start off as corporate
        standards. OData (also discussed in Chapter 10) started as a Microsoft project, but it
        was submitted to OASIS in 2012 and will eventually become an OASIS standard.

    Open Standards
        An open standard has gone through a process of design by committee, or at least had
        an open comment period during which a lot of people read the specification, complained
        about it, and made suggestions for improvement. At the end of this process, the speci‐
        fication was blessed by some kind of recognized standards body

        This process gives an open standard a certain amount of moral force. If there’s an open
        standard that does more or less what you want, you really should use it instead of making
        up your own fiat standard. The design process and the comment period probably turned
        up a lot of issues that you won’t encounter until it’s too late.


    Requests for Comments (RFCs) and Internet-Drafts

        An RFC begins life as an Internet-Draft. This is a document that looks like a standards
        document, but you’re not supposed to build implementations based on it. You’re sup‐
        posed to find problems with the specification and give feedback.
        An Internet-Draft has a built-in lifetime of six months. Six months after it is published,
        a draft must be approved as an RFC or replaced with an updated draft. If neither of
        those things happens, then the draft expires and should not be used for anything. On
        the other hand, if the draft is approved, it expires immediately and is replaced by an RFC.

        For example, I’ll refer to the HTTP/ 1.1 specification as RFC 2616.

===============================================================================================================
===============================================================================================================
Chapter  1 - Surfing the web

    As far as this book is concerned, the Web is based on three technologies: the URL naming
    convention, the HTTP protocol, and the HTML document format. URL and HTTP are
    simple, but to apply them to distributed programming you must understand them in
    more detail than the average web developer does. The first few chapters of this book are
    dedicated to giving you this understanding.

    Resources and Representations
        Resources = The URL http://www.youtypeitwepostit.com/ identifies a resource—probably the home
        page of the website advertised on the billboard

        Representations = When a web browser sends an HTTP request for a resource, the server sends a document
        in response (usually an HTML document, but sometimes a binary image or something
        else). Whatever document the server sends, we call that document a representation of the resource.

!!!!    So each URL identifies a resource. When a client makes an HTTP request to a URL, it
        gets a representation of the underlying resource. The client never sees a resource directly

    Addressability
        The principle of addressability just says that every resource should have its own URL.
        If something is important to your application, it should have a unique name, a URL, so
        that you and your users can refer to it unambiguously (a counter example would be a Flash website where
        everything is at the same address...)

    Short sessions
!!!     HTTP sessions last for one request. The client sends a request, and the server responds.
        This means Alice could turn her phone off overnight, and when her browser restored
        the page from its internal cache, she could click on one of the two links on this page and
        it would still work. (Compare this to an SSH session, which is terminated if you turn your computer off.)

        Alice could leave this web page open in her phone for six months, and when she finally
        clicks on a link, the web server would respond as if she’d only waited a few seconds. The
        web server isn’t sitting up late at night worrying about Alice. When she’s not making an
        HTTP request, the server doesn’t know Alice exists.

!!!!!   This principle is sometimes called statelessness. I think this is a confusing term because
        the client and the server in this system both keep state; they just keep different kinds of
        state. The term “statelessness” is getting at the fact that the server doesn’t care what state
        the client is in.

    The HTTP standard (RFC 2616) defines eight methods a client can apply to a resource.
    In this book, I’ll focus on five of them: GET, HEAD, POST, PUT, and DELETE. In
    Chapter 3, I’ll cover these methods in detail, along with an extension method, PATCH,
    designed specifically for use in web APIs. Right now the important thing to keep in mind
    is that there are a small number of standard methods.


    Application state
        Every state in this diagram corresponds to a particular page (or to no page at all) being
        open in Alice’s browser window. In REST terms, we call this bit of information—which
        page are you on?—the application state.

    Resource State
        When the story begins, there are two messages in the message list: “Hello” and “Later.”
        Sending a GET to the home page doesn’t change resource state, since the home page is
        a static document that never changes. Sending a GET to the message list won’t change the state either.
        But when Alice sends a POST to the message list, it puts the server in a new state. Now
        the message list contains three messages: “Hello,” “Later,” and “Test.”

    Because HTTP sessions are so short, the server doesn’t know anything about a client’s
    application state. The client has no direct control over resource state—all that stuff is
    kept on the server. And yet, the Web works. It works through REST—representational
    state transfer.

    Application state is kept on the client, but the server can manipulate it by sending rep‐
    resentations—HTML documents, in this case—that describe the possible state transi‐
    tions. Resource state is kept on the server, but the client can manipulate it by sending
    the server a representation—an HTML form submission, in this case—describing the
    desired new state

    Connectedness
        The strands of the web are the HTML <a> tags and <form>
        tags, each describing a GET or POST HTTP request Alice might decide to make. I call
!!      this the principle of connectedness: each web page tells you how to get to the adjoining pages.

!!!!!   The Web as a whole works on the principle of connectedness (see above), which is better known as
        “hypermedia as the engine of application state,” sometimes abbreviated HATEOAS. I
        prefer “connectedness” or “the hypermedia constraint,” because “hypermedia as the en‐
        gine of application state” sounds intimidating. But at this point, you should have no
        reason to find it intimidating. You know what application state is—it’s which web page
        a client is on. Hypermedia is the general term for things like HTML links and forms:
        the techniques a server uses to explain to a client what it can do next.
        To say that hypermedia is the engine of application state is to say that we all navigate
        the Web by filling out forms and following links.

!!! Web APIs Lag Behind the Web
        1. Web APIs frequently have human-readable documentation that explains how to
           construct URLs for all the different resources. This is like writing English prose
           explaining how to find a particular file on an FTP server. If websites did this, no
           one would bother to use the Web.
           Instead of telling you what URLs to type in, websites embed URLs in <a> tags and
           <form> tags—hypermedia controls that you can activate by clicking a link or a button.
           In REST terms, putting information about URL construction in separate human readable documents violates the
           principles of connectedness and self-descriptive messages.

        2. Lots of websites have help docs, but when was the last time you used them? Unless
           there’s a serious problem (you bought something and it was never delivered), it’s
           easier to click around and figure out how the site works by exploring the connected,
           self-descriptive HTML documents it sends you.
           Today’s APIs present their resources in a big menu of options instead of an inter‐
           connected web. This makes it difficult to see what one resource has to do with another.

       3. Integrating with a new API inevitably requires writing custom software, or instal‐
          ling a one-off library written by someone else. But you don’t need to write custom
          software to use a new website. You see a URL on a billboard and plug it into your
          web browser—the same client you use for every other website in the world.

       4. When APIs change, custom API clients break and have to be fixed. But when a
          website undergoes a redesign, the site’s users grumble about the redesign and then
          they adapt. Their browsers don’t stop working.
          In REST terms, the website redesign is entirely encapsulated in the self-descriptive
          HTML documents served by the website. A client that could understand the old
          HTML documents can understand the new ones

===============================================================================================================
===============================================================================================================
Chapter  2 - A simple API

!!! The ideal API would have the same characteristics that make the World Wide Web easy
    to use. As a developer, you would be able to figure out how to use it, starting with nothing
    but a URL you saw on a billboard.

    HTTP GET: Your Safe Bet

        The HTTP standard says that a GET request is a request for a representation. It’s not
        intended to change any resource state on the server. This means that if you have a URL
        to a resource and don’t know anything more, you can always make a GET request and
        get a representation in return. Your GET request won’t do something disastrous like
        delete all the data. We say that GET is a safe method

        (It’s OK for the server to change incidental things because of a GET request, like incre‐
         menting a hit counter or logging the request to a file, but that’s not the purpose of the
         GET request. Nobody makes an HTTP request just to increment the hit counter)

!!! How to Read an HTTP Response
        Well, every HTTP response can be split into three parts:

        1. The status code, sometimes called the response code
           This is a three-digit number that summarizes how the request went. The response
           code is the first thing an API client sees, and it sets the tone for the rest of the
           response. Here, the status code was 200 (OK). This is the status code a client hopes
           for—it means that everything went fine.
        2. The entity-body, sometimes called just the body
           This is a document written in some data format, which the client is expected to
           understand. If you think of a GET request as a request for a representation, you can
           think of the entity-body as the representation (technically, the entire HTTP response is the
           ‘representation’, but the important information is usually in the entitybody).
        3. The response headers
           These are a series of key-value pairs describing the entity-body and the HTTP re‐
           sponse in general. Response headers are sent between the status code and the entitybody

!!!!        The most important HTTP header is Content-Type, which tells the HTTP client
            how to understand the entity-body. It’s so important that its value has a special
            name. We say the value of the Content-Type header is the entity-body’s media
            type. (It’s also called the MIME type or the content type. Sometimes “media type” is
            hyphenated: media-type.)
            (example : the most common media types are text/html (for HTML) and image types like image/jpeg)

    JSON
        If you’re a web developer, you probably recognize this entity-body as a JSON document.
        In case you don’t, here’s a very quick introduction to JSON.
        JSON, described in RFC 4627, is a standard for representing simple data structures in
        plain text. It uses double quotes to describe strings:
            "this is a string"
        It uses square brackets to describe lists:
            [1, 2, 3]
        It uses curly brackets to describe objects (collections of key-value pairs):
            {"key": "value"}

        So what is this application/vnd.collection+json stuff? Clearly this format is based
        on JSON, since it looks like JSON and its media type has “json” in the name. But what is it, really?

        In Chapter 6, I’ll talk about Collection+JSON in detail, but here’s the short version.
        Collection+JSON is a standard for publishing a searchable list of resources over the Web.
        JSON puts constraints on plain text, and Collection+JSON puts constraints on JSON.
        A server can’t serve just any JSON document as application/vnd.collection+json.
        It can only serve a JSON object:
            {}
        But not just any object. The object has to have a property called collection, which
        maps to another object:
            {"collection": {}}
        The “collection” object ought to have a property called items that maps to a list:
            {"collection": {"items": []}}
        The items in the “items” list need to be objects:
            {"collection": {"items": [{}, {}, {}]}}
        And on and on, constraint after constraint...

!!!!    Collection+JSON is a way of serving lists—not lists of data structures, which you can
        do with normal JSON, but lists that describe HTTP resources

!!!     A document that doesn’t follow these rules isn’t a Collection+JSON document: it’s just
        some JSON. By allowing yourself to be bound by Collection+JSON’s constraints, you
        gain the ability to talk about concepts like resources and URLs. These concepts are not
        defined in JSON, which can only talk about simple things like strings and lists.

    HTTP POST: How Resources Are Born

        here’s the response I got to my POST request:
            201 Created
            Location: http://www.youtypeitwepostit.com/api/47210977342911065
        When you get a 201 response code, the Location header tells you where to look for the
        thing you just created. RFC 2616 specifies the meaning of the 201 response code and
        the Location header, but the Collection+JSON specification mentions this as well, just to be clear.

    Application Semantics Create the Semantic Gap
        Of course, the Collection+JSON constraints don’t constrain everything. Collection
        +JSON doesn’t specify that the items in a collection should be microblog posts with a
        date_posted and a text. I made that part up, because I wanted to design a simple
        microblogging example for this book. If I’d chosen to do a “recipe book” example, I
        could still use Collection+JSON, but the items would have data fields like ingredi
        ents and preparation_time.
!!      I’m going to call these extra bits of design the application semantics, because they vary
        from one application to another. Application semantics are the cause of the semantic
        gap I mentioned in Chapter 1.

!!!     If the publishers of microblogging APIs got together and agreed to use a common set
        of application semantics, the semantic gap for microblogging would disappear almost
        entirely. (This would be a profile, and I’ll cover this idea in Chapter 8.) The more con‐
        straints we share and the more compatible our designs, the smaller the semantic gap
        and the more our users benefit.

        Maybe you don’t want your API to be interoperable with your competitor’s APIs, but
        there are better ways to differentiate yourself than by artificially widening the semantic
        gap. My goal for this book is to get you focused on the parts of your API that have
        something new to offer, in the spots where a semantic gap exists because no one else
        has ever taken that path.

===============================================================================================================
===============================================================================================================
Chapter  3 - Resources and representations

    there’s no RFC for REST the way there is for HTTP or JSON.

    REST is not a protocol, a file format, or a development framework. It’s a set of design
    constraints: statelessness, hypermedia as the engine of application state, and so on. Col‐
    lectively, we call these the Fielding constraints, because they were first identified in Roy
    T. Fielding’s 2000 dissertation on software architecture, which gathered them together
    under the name “REST.”

    A Resource Can Be Anything
        A resource is anything that’s important enough to be referenced as a thing in itself. If
        your users might “want to create a hypertext link to it, make or refute assertions about
        it, retrieve or cache a representation of it, include all or part of it by reference into another
        representation, annotate it, or perform other operations on it” (Architecture), you
        should make it a resource.

        A resource is usually something that can be stored on a computer: an electronic docu‐
        ment, a row in a database, or the result of running an algorithm. Architecture calls these
        “information resources,” because their native form is a stream of bits. But a resource can
        be anything at all: a pomegranate, a human being, the color black, the concept of courage,
        the relationship between mother and daughter, or the set of all prime numbers. The only
        restriction is that every resource must have a URL.

!!!     From the client’s perspective, it doesn’t matter what a resource is, because the client
        never sees a resource. All it ever sees are URLs and representations.

    A Representation Describes Resource State
        When a client issues a GET request for a resource, the server should serve a document
        that captures the resource in a useful way. That’s a representation—a machine-readable
        explanation of the current state of a resource.

        The server might describe a database row as an XML document, a JSON object, a set of
        comma-separated values, or as the SQL INSERT statement used to create it. These are
        all legitimate representations; it depends on what the client asks for

!!!     A representation can be any machine-readable document containing any information about a resource.

    Representations Are Transferred Back and Forth
        When a client makes a POST request to create a new resource, it sends a representation:
        the client’s idea of what the new resource should look like. The server’s job is to create
        that resource, or else refuse to create it. The client’s representation is just a suggestion.
        The server may add to, alter, or ignore any part of it. (Here, the server added a date_posted value
        to the data.)

        The Web works the same way. Back in Chapter 1, my fictional character Alice created
        a new entry on a microblogging website by sending a POST request, along with a rep‐
        resentation in application/x-www-form-urlencoded format:
            message=Test&submit=Post
        That doesn’t look anything like the complex HTML document Alice got in return, but
        they were both representations of a microblog post that says, “Test.”

!!!     We think of representations as something the server sends to the client. That’s because
        when we surf the Web, most of our requests are GET requests. We’re asking for repre‐
        sentations. But in a POST, PUT, or PATCH request, the client sends a representation to
        the server. The server’s job is then to change the resource state so it reflects the incoming
        representation

!!!!!   The server sends a representation describing the state of a resource. The client sends a
        representation describing the state it would like the resource to have. That’s represen‐
        tational state transfer (REST).

    Resources with Many Representations
        A resource can have more than one representation. Government documents are often
        made available in multiple languages. Some resources have an overview representation
        that doesn’t convey much state, and a detail representation that includes everything.
        Some APIs serve the same data in JSON and XML-based data formats. When this hap‐
        pens, how is the client supposed to specify which representation it wants?

        There are two strategies, and I’ll describe them in detail in Chapter 11. The first is content
        negotiation, in which the client distinguishes between representations based on the
        value of an HTTP header. The second is to give the resource multiple URLs—one URL
        for every representation.

        Just as one person may be addressed by different names in different contexts,1 one
        resource may be identified by many URLs. (Dan, Mr Testehan, Teshte)

    The Protocol Semantics of HTTP
        The HTTP standard defines eight different kinds of messages. These four are the most
        commonly used:
            GET - Get a representation of this resource.
            DELETE - Destroy this resource.
            POST - Create a new resource underneath this one, based on the given representation.
            PUT - Replace this state of this resource with the one described in the given representation.
        These two methods are mostly used as a client explores an API:
            HEAD - Get the headers that would be sent along with a representation of this resource, but
                    not the representation itself.
            OPTIONS - Discover which HTTP methods this resource responds to.

        (The other two methods defined in the HTTP standard, CONNECT and TRACE, are
         only used with HTTP proxies. I won’t be covering them.)

    GET
        You’re surely familiar with this method already. The client sends a GET request to ask
        for a representation of a resource, identified by a URL.

!!!!    Sending a GET request to the server should have the same effect on re‐
        source state as not sending a GET request—that is, no effect at all. Incidental side effects
        like logging and rate limiting are OK, but a client should never make a GET request
        hoping that it will change the resource state.

        The most common response code to a GET request is 200 (OK). Redirect codes like 301
        (Moved Permanently) are also common.

    DELETE
        The client sends a DELETE request when it wants a resource to go away. The client
        wants the server to destroy the resource and never refer to it again. Of course, the server
        is not obliged to delete something it doesn’t want to.

        If a DELETE request succeeds, the possible status codes are 204 (No Content, i.e., “it’s
        deleted, and I don’t have anything more to say about it”), 200 (OK, i.e., “it’s deleted, and
        here’s a message about that”); and 202 (Accepted, i.e., “I’ll delete it later”).
        If a client tries to GET a resource that has been DELETEd, the server will return an error
        response code, usually 404 (Not Found) or 410 (Gone)

    Idempotence
        DELETE method has another useful property: it’s idempotent.

        Once you delete a resource, it’s gone. The resource state has permanently changed. You
        can send another DELETE request, and you might get a 404 error, but the resource state
        is exactly as it was after the first request. The resource is still gone.

        idempotence = Sending a request twice has the same effect on resource state as sending it once.

        Idempotence is a useful feature, because the Internet is not a reliable network. Suppose
        you send a DELETE request and your connection times out. You never got a response,
        so you don’t know if the DELETE went through. You can just send that DELETE request
        again, and keep trying until you get a response. Nothing extra will happen if a DELETE
        goes through twice instead of once.

        The notion of idempotence comes from math. Multiplying a number by zero is an
        idempotent operation. 5 × 0 is zero, but 5 × 0 × 0 is also zero.
        HTTP DELETE effectively multiplies a resource by zero.
        Multiplying by 1 is a safe operation, the way HTTP GET is supposed to be safe. You can
        multiply a number by 1 all day long, and nothing will change.
        Every safe operation is also idempotent.

    POST-to-Append
        The POST method has two jobs, which I’ll cover separately.
        The first is POST-to-append, in which sending a POST request to a resource creates a new resource underneath it.
        When a client sends a POSTto-append request, it sends a representation of the resource it wants to create in the
        request’s entity-body.

        The most common response code to a POST-to-append request is 201 (Created). It lets
        the client know that a new resource was created. The Location header lets the client
        know the URL to this new resource. Another common response code is 202 (Accept
        ed), which means that the server intends to create a new resource based on the given
        representation, but hasn’t actually created it yet.

        That’s POST-to-append. But you’ve probably used POST for all sorts of things other
        than “create a new resource.” That’s the other job of POST. That’s called overloaded
        POST, and I’ll talk about it later in this chapter.

    PUT
        A PUT request is a request to modify resource state. The client takes the representation
        it got from a GET request, modifies it, and sends it back as the payload of a PUT request.

        If the server decides to accept a PUT request, the
        server changes the resource state to match what the client says in the representation,
        and usually sends either 200 (OK) or 204 (No Content).

        PUT is idempotent, just like DELETE. If you send the same PUT request 10 times, the
        result is the same as if you’d only sent it once.

        PUT is an idempotent operation even when you use it to create a new resource. If I send that PUT request
        five times, it won’t create five posts with the same text (the way five POST requests might).

    PATCH
        The PUT rule can also lead to unintentional conflicts with other users who
        are modifying the same document. It would be nice if you could just send the server the
        parts of the document you want to change.

        The PATCH method allows for this. Instead of PUTting a full representation, you can
        create a special “diff ” representation and send it to the server as the payload of a PATCH request.

        The best response codes for a successful PATCH are the same as for PUT and DELETE:
        200 (OK) if the server wants to send data (such as an updated representation of the
        resource) along with its response, and 204 (No Content) if the server just wants to
        indicate success.

!!      Remember that PATCH is not defined in the HTTP specification. It’s an extension de‐
        signed specifically for web APIs, and it’s relatively recent (RFC 5789 was published in
        2010). This means that tool support for PATCH, and for the diff documents it uses, is
        not as good as the support for PUT.

    LINK and UNLINK
        LINK and UNLINK manage the hypermedia links between resources. To understand
        these methods, you must understand hypermedia and link relations, so I’m going to
        defer a detailed discussion to Chapter 11.

        LINK and UNLINK are idempotent, but not safe. These methods are defined in an
        Internet-Draf

    HEAD
        HEAD is a safe method, just like GET. In fact, it’s best to think of HEAD as a lightweight
        version of GET. The server is supposed to treat a HEAD request exactly the same as a
        GET request, but it’s not supposed to send a an entity-body—only the HTTP status code
        and the headers

        Using HEAD instead of GET may not save any time (the server still has to generate all
        the appropriate HTTP headers), but it will definitely save bandwidth.

    OPTIONS
        OPTIONS is a primitive discovery mechanism for HTTP. The response to an OPTIONS
        request contains the HTTP Allow header, which lays out which HTTP methods the
        resource supports.

!!!     OPTIONS is a good idea, but almost nobody uses it. Well-designed APIs advertise a
        resource’s capabilities by serving hypermedia documents (see Chapter 4) in response to
        GET requests. The links and forms in those documents explain what HTTP requests a
        client can make next. Poorly designed APIs use human-readable documentation to ex‐
        plain which HTTP requests a client can make.

    Overloaded POST
!!!!!   Now it’s time to reveal the skeleton in the HTTP closet. The HTTP POST method has
        a dirty secret, one you’ve certainly encountered if you’ve ever worked in web develop‐
        ment. POST is not solely used to create new resources. On the Web we surf with our
        browsers, HTTP POST is used to convey any kind of change. It’s PUT, DELETE, PATCH,
        LINK, and UNLINK all rolled into one.

!!!!!   In terms of protocol semantics, this operation—“edit this blog post”—sounds like a PUT
        request. But an HTML form can’t trigger a PUT request. The HTML data format doesn’t
        allow it. So we use POST instead.

        The definition is so vague that a POST request really has no protocol semantics at all. POST doesn’t
        really mean “create a new resource”; it means “whatever!”
        I call this “whatever!” usage of POST overloaded POST. Because an overloaded POST
        request has no protocol semantics, you can only understand it in terms of its application
        semantics.

    Which Methods Should You Use?
        The protocol semantics of HTTP are mostly defined by the HTTP methods. But there’s
        a lot of redundancy in these methods. PUT can substitute for PATCH. GET can do the
        job of HEAD. POST can substitute for anything. Do we really need all these methods?

        The methods I recommend for use in most web APIs are GET, POST, PUT, DELETE,
        and PATCH. But I can think of a lot of cases where I’d recommend different methods:
            • Before 2008, the PATCH method didn’t exist. Back then, the method set I recom‐
            mended for web APIs was GET, POST, PUT, and DELETE
            • When we humans surf around on our web browsers, we completely ignore most of
            the methods defined in the HTTP specification, and get by with just GET and POST.
            That’s because the protocol semantics of HTML documents only allow for GET and POST.

===============================================================================================================
===============================================================================================================
Chapter  4 - Hypermedia

    Look closer, and you’ll see a question that hasn’t been answered: how does the client
    know which requests it can make? There are infinitely many URLs. How does a client
    know which URLs have representations behind them and which ones will give a 404
    error? Should the client send an entity-body with its POST request? If so, what should
    the entity-body look like?

!!! The missing piece of the puzzle is hypermedia. Hypermedia connects resources to each
    other, and describes their capabilities in machine-readable ways. Properly used, hyper‐
    media can solve—or at least mitigate—the usability and stability problems found in
    today’s web APIs.

    Like REST, hypermedia isn’t a single technology described by a standards document
    somewhere. Hypermedia is a strategy, implemented in different ways by dozens of technologies

!!!!! The hypermedia strategy always has the same goal. Hypermedia is a way for the server
      to tell the client what HTTP requests the client might want to make in the future. It’s a
      menu, provided by the server, from which the client is free to choose. The server knows
      what might happen, but the client decides what actually happens.

    But in the world of APIs, hypermedia is a confusing and controversial topic.
    That’s why today’s APIs are terrible at managing change.
    In this chapter, I want to dispel the mystery of hypermedia, so you can create APIs that
    have some of the flexibility of the Web.

    HTML as a Hypermedia Format
        The <a> tag is a simple hypermedia control. It’s a description of an HTTP request your
        browser might make in the near future. An <a> tag is a signal to your browser that it
        can make an HTTP GET request
        An <a> tag is a promise from the web server that a certain URL names a resource you can visit

!!!     To sum up, the familiar HTML controls allow the server to describe four kinds of HTTP requests.
        • The <a> tag describes a GET request for one specific URL, which is made only if
        the user triggers the control.
        • The <img> tag describes a GET request for one specific URL, which happens auto‐
        matically, in the background.
        • The <form> tag with method="POST" describes a POST request to one specific URL,
        with a custom entity-body constructed by the client. The request is only made if
        the user triggers the control.
        • The <form> tag with method="GET" describes a GET request to a custom URL con‐
        structed by the client. The request is only made if the user triggers the control.

        Fielding (guy who first wrote about REST) dissertation:
        Hypermedia is defined by the presence of application control information embedded
        within, or as a layer above, the presentation of information.

        The World Wide Web is full of HTML documents, and the documents are full of things
        people like to read—prices, statistics, personal messages, prose, and poetry. But all of
        those things fall under  "presentation of information"

        It’s the "application control information" that distinguishes an HTML document from a
        book. I’m talking about the hypermedia controls that people interact with all the time,
        but rarely examine closely. The <img> tags that tell the browser to embed certain images,
        the <a> tags that transport the end user to another part of the Web

    URI Templates
        But URI Templates, a different hypermedia technology, can do this. URI Templates are defined in RFC 6570,
        and they look like this:
            http://www.youtypeitwepostit.com/search/{search}
        That’s not a valid URL, because it contains curly brackets.
        Those brackets identify the string as a URI Template. RFC 6570 tells you how to turn that string into an
        infinite number of URLs. It says you can replace {search} with any string you want, so long as
        that string would be valid in a URL:
            • http://www.youtypeitwepostit.com/search/rest
            • http://www.youtypeitwepostit.com/search/RESTful%20Web%20APIs

        Although a URI Template is shorter and more flexible than an HTML GET form, the
        two technologies aren’t much different. URI Templates and HTML forms allow a web
        server to describe an infinite number of URLs with a short string. The HTTP client can
        plug in some values, choose one URL from that infinite family, and make a GET request
        to that specific URL.

        URI Templates don’t make sense on their own. A URI Template needs to be embedded
        in a hypermedia format. The idea is that every standard that needs this functionality
        should just use URI Templates, instead of defining a custom format, which is what was
        happening before RFC 6570 was published.

    URI Versus URL
        A URL is a short string used to identify a resource. A URI is also a short string used to
        identify a resource. Every URL is a URI. They’re described in the same standard: RFC 3986.

!!!!!   What’s the difference? As far as this book is concerned, the difference is this: there’s no
        guarantee that a URI has a representation. A URI is nothing but an identifier. A URL is
        an identifier that can be dereferenced. That is, a computer can somehow take a URL and
        get a representation of the underlying resource

        Here’s a URI that’s not a URL: urn:isbn:9781449358063. It designates a resource: the
        print edition of this book. Not any particular copy of this book, but the abstract concept
        of an entire edition. (Remember that a resource can be anything at all.) This URI is not
        a URL because… what’s the protocol? How would a computer get a representation? You
        can’t do it.

        Without a URL, you can’t get a representation. Without representations, there can be
        no representational state transfer.

        Here’s a URL that identifies the print edition of this book: http://shop.oreilly.com/prod
        uct/0636920028468.do.

!!!     In general, when your web API refers to a resource, it should use a URL with the http
        or https scheme, and that URL should work: it should serve a useful representation in
        response to a GET request.

    The Link Header
        Here’s a technology that puts hypermedia where you might not expect it: inside the
        headers of an HTTP request or response. RFC 5988 defines an extension to HTTP, a
        header called Link. This header lets you add simple hypermedia controls to entitybodies that don’t normally
        support hypermedia at all, like JSON objects and binary image files.

        Here’s a plain-text representation of a story that’s been split into multiple parts with
        cliffhangers (the entity-body of this HTTP response contains the first part of the story,
        and the Link header points to the second part)

            HTTP/1.1 200 OK
            Content-Type: text/plain
            Link: <http://www.example.com/story/part2>;rel="next"
            It was a dark and stormy night. Suddenly, a...
            (continued in part 2)

        The Link header has approximately the same functionality as an HTML <a> tag. I rec‐
        ommend you use real hypermedia formats whenever possible, but when that’s not an
        option, the Link header can be very useful.

    What Hypermedia Is For
        Hypermedia controls have three jobs:
            • They tell the client how to construct an HTTP request: what HTTP method to use,
            what URL to use, what HTTP headers and/or entity-body to send.
            • They make promises about the HTTP response, suggesting the status code, the
            HTTP headers, and/or the data the server is likely to send in response to a request.
            • They suggest how the client should integrate the response into its workflow.

    Guiding the Request
        An HTTP request has four parts: the method, the target URL, the HTTP headers, and
        the entity-body. Hypermedia controls can guide the client into specifying all four of these.

        This HTML <a> tag specifies both the target URL and the HTTP method to use:
            <a href="http://www.example.com/">An outbound link</a>
        The target URL is defined explicitly, in the href attribute. The HTTP method is defined
        implicitly: the HTML spec says that an <a> tag becomes a GET request when the end
        user clicks the link.

        This HTML form defines the method, the target URL, and the entity-body of a potential
        future HTTP request:
            <form action="/stores" method="get">
             <input type="text" name="storeName" value="" />
             <input type="text" name="nearbyCity" value="" />
             <input type="submit" value="Lookup" />
            </form>

        Ordinarily, the entity-body of an HTML POST form is form-encoded, and sent over
        the network with the Content-Type header set to application/x-www-formurlencoded. But specifying the enctype
        attribute of the <form> tag overrides this behavior. A form with enctype="text/plain" tells the browser to
        encode its entity-body in a plain text format, and to send it over the network with the Content-Type header
        set to text/plain.

    Workflow Control
        An HTML document can embed more than images. Here’s some HTML markup that
        downloads and runs some executable code written in JavaScript:
            <script type="application/javascript" src="/my_javascript_application.js"/>
        Here’s some markup that downloads a CSS stylesheet and applies it to the main document:
            <link rel="stylesheet" type="text/css" href="/my_stylesheet.css"/>

        The process of embedding one document in another is also called transclusion.

    Beware of Fake Hypermedia

        HTTP/1.1 200 OK
        Content-Type: application/json
        {
         "title": "Example: A Novel",
         "description": "http://www.example.com/"
        }

        This is a representation of a book. The description field happens to look like a URL:
        http://www.example.com/. But is this a link? Is description supposed to link to a re‐
        source that gives the description? Or is it supposed to be a textual description, and some
        smart aleck typed in some text that happens to be a valid URL?

        If you’re trying to consume an API like this, you won’t get very far dogmatically denying
        the existence of links. Instead, you’ll read some human-readable documentation written
        by the API provider. That documentation will explain the conventions the provider used
        to embed hypermedia links in a format (JSON) that doesn’t support hypermedia. Then
        you’ll know how to distinguish between links and strings, and you’ll be able to write a
        client that can detect and follow the hypermedia links.
        But your client will only work for that specific API

!!!!!   That’s why API designers shouldn’t design APIs that serve plain JSON. You should use
        a media type that has real support for hypermedia. Your users will thank you. They’ll
        be able to use preexisting libraries written against the media type, rather than writing
        new ones specifically for your API.

        JSON has been the most popular representation format for APIs for quite a while, but
        as recently as a couple years ago, there were no JSON-based hypermedia formats. As
        you’ll see in the next few chapters, that has changed. Don’t worry that you’ll have to give
        up JSON to gain real hypermedia.


    The Semantic Challenge: How Are We Doing?
         At the end of Chapter 1, I set out a challenge: “How can we program a computer to
         decide which links to click?” A web browser works by passing the representations it gets
         to a human, who makes all the decisions. How can we get similar behavior without
         consulting a human at each step?

!!!!!    Providing the links is a step in the right direction. Out of the infinite set of legal HTTP
         requests, a hypermedia document explains which requests might be useful right now,
         on this particular site. The client doesn’t have to guess.

         But that’s not enough. Suppose an HTML document contains only two links, A and B.
         Two possible requests the client might make. How does the client choose? On what basis
         can it make its decision?

         When I think about application semantics, I usually think on a higher level than that. I
         think about the concepts that separate a wiki from an online store. They’re both websites,
         they both use embedded images and scripts, but they mean very different things.

!!!!!    A hypermedia format doesn’t have to be generic like HTML. It can be defined in enough
         detail to convey the application semantics of a wiki or a store. In the next chapter, I’ll
         talk about hypermedia formats that are designed to represent one specific type of prob‐
         lem. Outside that problem space, they’re practically useless. But within their limits, they
         meet the semantic challenge very well.

===============================================================================================================
===============================================================================================================
Chapter  5 - Domain specific designs

    In this chapter, I’ll choose a problem space and implement a web API for representing
    it. The details of the problem space don’t matter. The technique is always the same.

    Figure 5-1 s shows a simple maze with one entrance and one exit. My server’s job will be
    to invent mazes like this and present them to clients.

!!  Although this is a frivolous example, the maze is a good metaphor for hypermedia
    applications in general. Any complex problem can be represented as a hypermedia maze
    that the client must navigate. If you’ve ever been trapped in a phone tree, or searched
    for products on an online store and then bought something from the search results,
    you’ve navigated a hypermedia maze.

    All of these APIs have the same shape as the maze games I’m about to show you:
        • The problem is too complex to be understood all at once, so it’s split up into steps.
        • Every client begins the process at the same first step.
        • At each step in the process, the server presents the client with a number of possible
        next steps.
        • At each step, the client decides what next step to take.
        • The client knows what counts as success and when to stop

    Maze+XML: A Domain-Specific Design
        That’s a graphical representation of a maze. It makes intuitive sense to a human, but a computer
        would need to run it through a machine vision algorithm to understand it. How can we represent the shape of
        a maze in a format that’s easy for a computer to understand?

        There are many possible solutions, but instead of designing a solution from scratch, I’m
        going to reuse some work that’s already been done. There’s a personal standard called
        Maze+XML, for representing mazes in a machine-readable format.
        The media type of a Maze+XML document is application/vnd.amundsen.maze+xml.

        In general, I don’t recommend creating new domain-specific media types. It’s usually
        less work to add application semantics to a generic hypermedia format—a technique
        I’ll cover in the next two chapters

        Each cell in a Maze+XML maze is an HTTP resource with its own URL. If you send a
        GET request to the first cell in this maze, you’ll get a representation that looks like this:
            <maze version="1.0">
             <cell href="/cells/M" rel="current">
             <title>The Entrance Hallway</title>
             <link rel="east" href="/cells/N"/>
             <link rel="west" href="/cells/L"/>
             </cell>
            </maze>

    Link Relations
        This representation shows off a powerful hypermedia tool called the link relation. By
        themselves, rel="east" and rel="west" don’t mean anything.
        But the Maze+XML standard defines meanings for “east” and “west,” and developers can program those
        definitions into their clients. Here are the definitions:

        east
            Refers to a resource to the east of the current resource. When used in the Maze
            +XML media type, the associated URI points to a neighboring cell resource to the
            east in the active maze.
        west
            Refers to a resource to the west of the current resource. When used in the Maze
            +XML media type, the associated URI points to a neighboring cell resource to the
            west in the active maze.

        A link relation is a magical string associated with a hypermedia control like Maze+XML’s
        <link> tag. It explains the change in application state (for safe requests) or resource
        state (for unsafe requests) that will happen if the client triggers the control

!!!!!   One of the most important web pages for a RESTful API developer is the registry of link
        relations managed by the Internet Assigned Numbers Authority (IANA).
            http://www.iana.org/assignments/link-relations/link-relations.xhtml
        I’ll be coming back to this registry throughout the book. It contains about 60 link relations that have
        been deemed to be generally useful and not tied to a particular data format. The simplest
        examples are the next and previous relations, for navigating a list.

!!!     RFC 5988 defines two kinds of link relations: registered relation types and extension
        relation types. Registered link relations look like the ones you see in the IANA registry:
        short strings like east and previous. To avoid conflicts, these short strings need to be
        registered somewhere—not necessarily with the IANA, but in some kind of standard
        such as the definition of a media type.
        Extension relations look like URLs. If you own mydoma.in, you can name a link relation
        http://mydoma.in/whatever and define it to mean anything you want. No one can
        define a link relation that conflicts with yours, since you control the domain. When
        your users visit http://mydoma.in/whatever in their web browsers, they should see a
        human-readable explanation of the link relation.

!!!     Chapter 9 includes a guide explaining when it’s OK to use the shorter names of registered
        relations. Here’s a summary:
            • You can use extension relations wherever you want.
            • You can use IANA-registered link relations whenever you want.
            • If a document’s media type defines some registered relations, you can use them
            within the document.
            • If a document includes a profile that defines some link relations (see Chapter 8),
            you can treat them as registered relations within that document.
            • Don’t give your link relations names that conflict with the names in the IANA
            registry

        (this refer to the string that is put in the "rel" attribute of the "link" html element)
         https://www.w3schools.com/tags/tag_link.asp

    The Collection of Mazes  (Dan : nice example of everything learned so far)
!!      The URL to the collection of mazes is the proverbial “URL advertised on the billboard.”
        Starting with no information but this URL, you can do everything it’s possible to do
        with a Maze+XML API:
            1. Start off by GETting a representation of the collection of mazes. You know how to
            parse the representation, because you read the Maze+XML specification and pro‐
            grammed this knowledge into your client.
            2. Your client also knows that the link relation maze indicates an individual maze. This
            gives it a URL it can use in a second GET request. Sending that GET request gives
            you the representation of an individual maze.
            3. Your client knows how to parse the representation of an individual maze (because
            you programmed that knowledge into it), and it knows that the link relation start
            indicates an entrance into the maze. You can make a third GET request to enter the
            maze.
            4. Your client knows how to parse the representation of a maze cell. It knows what
            east, west, north, and south mean, so it can translate movement through an ab‐
            stract maze into a series of HTTP GET requests.
            5. Your client knows what exit means, so it knows when it’s completed a maze.

        There’s more to the Maze+XML standard, but you’ve now seen the basics. A collection
        links to a maze, which links to a cell. From one cell you can follow links to other cells.
        Eventually you’ll find a cell with an exit link leading out of the maze. That’s enough
        information to start writing clients.

    Is Maze+XML an API?
!!!!    If you’ve got experience in this field, you may be wondering: where’s the API? A maze
        game isn’t a complex application, but even so, you may have expected more than a few
        XML tag names and link relations. The Maze+XML specification lacks the things you
        may be accustomed to. It doesn’t define any API calls or give any rules for constructing
        URLs. In fact, it barely mentions HTTP at all! I’ve shown some URLs in the example
        representations, but I deliberately made the URL formats internally inconsistent (com‐
        pare /beginner to /expert-maze/start) so you wouldn’t think URL formats were defined
        by the standard.

!!      My experience shows that the “API call” metaphor inevitably exposes the server’s im‐
        plementation details to the clients. This introduces coupling between server code and
        client code. When all the people involved with the API are friends and colleagues, this
        doesn’t matter so much.

!!!!!   But this book focuses on web APIs, which is to say, web-scale APIs (i.e., APIs where any
        member of the public can use a client, or write a client, or, in some cases, write a server).
        When you allow someone outside your organization to make API calls, you make that
        person a silent partner in the implementation of your server. It becomes very difficult
        to change anything on the server side without hurting this unknown customer

        This is why public APIs change so rarely. You can’t change an API based on API calls
        without causing huge pain among your users

!!      Designs based on hypermedia have more flexibility. Every time the client makes an
        HTTP request, the server sends a response explaining which HTTP requests make the
        most sense as a next step. If the server-side options change, that document changes
        along with it. This doesn’t solve all of our API problems—the semantic gap is a huge
        problem!—but it solves the one we know how to solve.

    Client #1: The Game
        The obvious use for the Maze+XML API is a game to be played by a human being. (source code for this is on
        github...it is a nodeJs app)

        We tend to think of an “API client” as an automated client. But human-driven clients
        like this have a big part to play in the modern API ecosystem. It’s very common for a
        mobile application, driven by a human, to communicate with a server through a web
        API. Best of all, with a human in the loop, the semantic gap is no problem

    Clients Do the Job They Want to Do
        These three clients—the Game, the Mapmaker, and the Boaster—all work from an un‐
        derstanding of the Maze+XML media type. But they have different goals, so they do
        different things with the same data

        This is fine. The server’s job is to describe mazes in a way that the client can engage with.
        The server’s job is not to dictate goals to the client. The Maze+XML spec describes a
        problem space, not a prescribed relationship between client and server. Client and server
        must share an understanding of the representations they’re passing back and forth, but
        they don’t need to have the same idea of what the problem is that needs to be solved.

    Extending a Standard
        Maze+XML is a contrived example in a frivolous problem domain. But let’s imagine
        that someone really does want to serve hypermedia mazes, either as part of a business
        or just for fun. That doesn’t automatically make Maze+XML the right answer. Even
        when a standard already exists for your problem domain, it probably won’t fit your
        needs exactly

        Creating an entirely new standard from scratch just to support three-dimensional mazes
        would be silly. The Maze+XML standard is almost good enough. I just have to extend
        it a little to make it support two new directions: up and down.
        Fortunately, Maze+XML explicitly allows this sort of extension (see section 5 of the
        specification). I can add anything I want to a Maze+XML document, so long as I don’t
        redefine something that’s already in the specification. To get my three-dimensional ma‐
        zes, I’ll just define two new link relations right here:
            up
                Refers to a resource spatially above the current resource.
            down
                Refers to a resource spatially below the current resource

        This is a simple extension, but it completely changes what a maze can look like, and
        how a maze can be stored on the server. My server implementation stores a maze in a
        two-dimensional array of cells, with each cell having four possible neighbors. To support
        these two new relations, I need to change the server code to reflect the fact that a maze
        is a three-dimensional array and each cell now has six possible neighbors

        But the client won’t see a big change at all. The client just sees two new link relations in
        the representations:
            <maze version="1.0">
             <cell href="/cells/middle-of-ladder">
             <title>The Middle of the Ladder</title>
             <link rel="up" href="/cells/top-of-ladder"/>
             <link rel="down" href="/cells/bottom-of-ladder"/>
             </cell>
            </maze>

        All that extra server-side complexity is hidden from the client by the very thing that
        makes the Maze+XML standard seem simplistic. The standard just doesn’t say much
        about what a maze “should” look like. Defining two new ways for cells to be connected
        requires a complete redesign of my server implementation, but the representations are
        still compliant with the Maze+XML standard, and the clients can still parse them.

!!!!    But this doesn’t mean the clients automatically understand these new application se‐
        mantics. Consider what happens when the Game, the Mapmaker, and the Boaster are
        served a three-dimensional maze.

!!!!!   Surprisingly, the Game works just fine! That client wasn’t hardcoded to know about the
        four cardinal directions. It was programmed to present every link it finds to the user,
        and to let the user choose between them. Since I chose the names “up” and “down” for
        my new link relations, a human being traversing a three-dimensional maze will see a
        screen with those new options

        The Boaster client also fares well in a three-dimensional maze, since it never even enters
        the maze. In fact, the Boaster should work on any Maze+XML-compatible server, no
        matter what extensions are made to it

        If the Mapmaker ever gets a representation like this, it will follow the “east” link and the
        “north” link, but never the “up” link. Set the Mapmaker loose on a three-dimensional
        maze and it will map one level of the maze. It will see only a two-dimensional slice of
        the maze.

        Even if the Mapmaker knew how to follow an “up” link, it wouldn’t know how to rep‐
        resent what it found at the other end of the link. The Mapmaker client has a twodimensional mind, just
        like our example server implementation. It generates twodimensional ASCII maps. A three-dimensional maze
        is completely incompatible with the Mapmaker client. (because the mapmaker draws the maze in ASCII chars,
        so it knows to draw just 2d mazes, not 3D)

        I’ve found that this rule holds in general. A client written against a specific server im‐
        plementation can be optimized for that server’s quirks, but it will fall down if you try to
        run it against another implementation of the same standard. This doesn’t mean the
        Mapmaker is a completely useless client; it’s just that it can only map certain mazes.

!!!     Imagine starting up a web browser that’s only ever been tested against one particular
        website. As soon as you send that browser to a site it wasn’t tested on, it’s going to crash.
        That’s the situation here. A standard like Maze+XML may have multiple server imple‐
        mentations. Client implementations need to be designed to work against all server im‐
        plementations, not just one.

    Maze as Metaphor
!!!!!   The similarity is no coincidence. As I said at the beginning of this chapter, the maze is
        a metaphor for hypermedia applications in general. Some “mazes” are tidy and wellbehaved. Others are chaotic
        and infinitely large. Thinking of a state diagram as a maze
        to be navigated will get you in the right frame of mind to understand hypermedia APIs.

    Meeting the Semantic Challenge
        For the designer of a domain-specific API, bridging the semantic gap is a two-step process:
            1. Write down your application semantics in a human-readable specification (like the
            Maze+XML standard).
            2. Register one or more IANA media types for your design, (like vnd.amundsen.ap
            plication/maze+xml. In the registration, associate the media types with the
            human-readable document you wrote. In Chapter 9, I’ll discuss the naming and
            registration process for media types.

        Your client developers can reverse the process to bridge the semantic gap in the other direction:
            1. Look up an unknown media type in the IANA registry.
            2. Read the human-readable specification to learn how to deal with documents of the
            unknown media type.

    Where Are the Domain-Specific Designs?
        When you need to publish an API, the first thing to do is to try to find an existing
        domain-specific design. There’s no point in duplicating someone else’s work.

        There are hundreds of domainspecific data formats, but not many of them include hypermedia controls

!!!!    But just because a data format doesn’t include hypermedia controls doesn’t mean it’s
        useless. In Chapter 8, I’ll show you how JSON-LD can add basic hypermedia capabilities
        to any JSON format. In Chapter 10, I’ll show how XForms and XLink can do the same
        for XML. These technologies let you graft hypermedia controls onto an existing API
        that doesn’t include them.

    The Prize at the End
        Consider the JPEG image format. It’s well documented, it’s got a registered media type
        (image/jpeg), and nothing beats a binary image file for representing a photograph. But
        you can’t use JPEG as the basis for a web API, any more than you could design a website
        that serves nothing but JPEGs. There’s no way for one JPEG to link to another.

!!!     It would be foolish to make up your own binary image format just
        because JPEG doesn’t have any hypermedia controls. But JPEG will not be the core of a
        hypermedia-based photo API. That honor will go to a format like HTML. HTML can’t
        represent a photograph, but it can embed a photograph in a textual document, pair a
        photograph with its caption, represent a list of photographs, and present forms for
        tagging and searching photographs.

!!!     An image/jpeg representation will be the client’s prize for navigating the photo API’s
        hypermedia “maze” and locating one specific photo. The “maze” itself will be described
        in a document format that supports hypermedia controls. The two formats will work
        together to form a complete API.

    Hypermedia in the Headers
!!!!    I showed in Chapter 4 how you can use the HTTP header Link to add simple hypermedia
        links and forms to documents that have no hypermedia controls of their own. Using
        these headers, you could conceivably design an API that served nothing but JPEG im‐
        ages, but I don’t recommend this.

    Steal the Application Semantics
        The hCard microformat lets you combine a vCard-like representation of a human being
        with the hypermedia links and forms needed to implement a full web API.

!!!!    This is another reason why it’s important to look for domain-specific data formats before
        you set off to design your API. A standard like vCard represents a lot of time and money
        spent identifying the application-level semantics for a problem domain. You don’t need
        to start over just because vCard doesn’t have hypermedia controls

        Even if you can’t directly reuse a domain-specific standard, you may be able to save
        yourself some time by adapting its application-level semantics into a profile. But that’s
        a topic for Chapter 8.

    If You Can’t Find a Domain-Specific Design, Don’t Make One
        If you can’t find a domain-specific API for your problem domain, don’t panic. People
        just don’t define reusable, domain-specific, hypermedia-aware formats very often. That
        doesn’t mean you have to start from scratch. You should be able to start with a stand‐
        ardized foundation and extend it, reusing work done by other people whenever possible.
        It’ll just take a little work on your part to glue everything together.

        In the next two chapters, I’ll discuss some of these foundations. In particular, there are
        a few domain-specific designs that deal with a domain so popular and so general—
        collections of things—that I don’t really consider it a domain at all. It’s more like a design
        pattern.

    Kinds of API clients
!!      A deep understanding of hypermedia won’t help you write a client for an API that doesn’t
        serve hypermedia documents. When you’re writing a client, you’re at the mercy of the
        server design, and pragmatism always trumps idealism. Right now, pragmatism means
        adopting a different approach for every individual API.

        This is my first attempt, presented humbly, to classify the clients
        we write to achieve our goals.

    Human-Driven Clients
        Human-driven clients can have relatively simple logic because they don’t have to make
        any decisions. They present representations to a human being, and convey the human’s
        decisions back to the server. The differences between human-driven clients come down
        to how faithful they are in presenting representations to their human users.

        The more devoted a client is to faithfully rendering the representations it receives, and
        not interposing its own judgment, the less likely it is to break when it encounters a
        representation it wasn’t expecting.

    Automated Clients
        Automated clients receive representations but don’t render them. There’s no human to
        see the rendering. These clients must bridge the semantic gap on their own, by deciding
        which hypermedia controls to trigger. Of course, most clients don’t “decide” anything
        at all. They carry out simple preprogrammed rulesets that hopefully help them reach
        some predefined goal.

        The crawler
            The crawler simulates a very curious but not very picky human. Give it a URL to start
            with, and it will fetch a representation. Then it will follow all the links it can find to get
            more representations. It will do this recursively, until there are no more representations
            to be had

            Generally speaking, a crawler will only trigger state transitions that are safe. Otherwise,
            there’s no telling what will happen to resource state. A crawler that sent a DELETE
            request to every resource it encountered, just to see what happened, would be a terrible
            client.

        The monitor
            The monitor is the opposite of the crawler. It simulates a human who’s obsessed with
            one particular web page. Give it a URL to start with, and the monitor will fetch a rep‐
            resentation of that URL and process it somehow. But it won’t follow any links. Instead,
            the monitor will wait a while and fetch a new representation of the same resource.
            Instead of triggering a hypermedia control to change the resource state, the monitor
            waits for someone else to change the resource state, and checks back later to see what
            happened.

        The script
            Most of today’s automated API clients are scripts. A script simulates a human with a set
            routine that never changes. A script happens when a human is tired of this routine and
            wants to automate it.

            The human chooses an API and figures out out which state transitions (for an API that
            serves hypermedia documents) or API calls (for a hypermedia-ignorant API) are nec‐
            essary to carry out the routine. Then the human writes an algorithm that automates the
            process of triggering those state transitions or making those API calls.

            A script tends to break when the assumptions underlying it become invalid. A “maze
            solver” client that always goes east three times can only solve a very small subset of
            mazes. A screen-scraping script that extracts data from a website will break when the
            HTML representations are redesigned.

!!!!        A hypermedia-aware script is less likely to break when something trivial happens, like
            the URL of a resource changing or new data being added to a representation. This means
            a hypermedia API has some room to change without breaking the scripts that depend
            on it. But a script is a playback of a human being’s thought process. If it encounters a
            situation the human didn’t originally consider, the script won’t be able to fill in the blanks.

        The agent
            A software agent simulates a human being who is actively engaged with a problem. It’s
            not as smart as a human, and it has no ability to make subjective judgments, but it does
            what a human would do in the same situation. It looks at a representation, analyzes the
            situation, and decides which hypermedia control to activate to get closer to its final goal.

            The monitor doesn’t do this; it never activates hypermedia controls at all. The crawler
            doesn’t do this; it activates every safe hypermedia control it can find. The script doesn’t
            do this; it always activates the next hypermedia control it was programmed with.
            Human-driven clients don’t do this; they delegate the task to the human. A software
            agent is the only client that can be said to make autonomous “decisions.”

            sophisticated agents would look like: the personal shoppers and automated news
            gatherers of science fiction, and the high-frequency trading algorithms used in real-life
            financial applications.

===============================================================================================================
===============================================================================================================
Chapter  6 - The collection pattern

    Collection+JSON is one of several standards designed not to represent one specific
    problem domain (the way Maze+XML does), but to fit a pattern—the collection—that
    shows up over and over again, in all sorts of domains. This standard makes a good
    example, because it’s a formalized version of the JSON-based APIs that first-time de‐
    signers tend to come up with. Collection+JSON lets you follow your natural design
    inclinations without running afoul of the Fielding constraints.

!!!!If there’s no domain-specific standard for your problem domain (and there probably
    isn’t), you may be able to use a collection-based standard instead. Instead of starting
    from nothing, you’ll be able to focus on adapting your application semantics to the
    collection pattern. Not only will you save time, you’ll get access to a preexisting base of
    client programs and server-side tools.

    Although this chapter focuses on Collection+JSON, I’ll also cover the Atom Publishing
    Protocol, or AtomPub. AtomPub is the original standard for collection-based APIs,
    defined in RFC 5023. It’s a relatively old standard, but apart from its use in Google’s
    public APIs, it hasn’t caught on—partly because it’s an XML-based format in a field now
    dominated by JSON representations.

    What’s a Collection?
        A collection is a special kind of resource. Recall from Chapter 3 that a resource is any‐
        thing important enough to have been given its own URL. A resource can be a piece of
        data, a physical object, or an abstract concept—anything at all. All that matters is that
        it has a URL and the representation—the document the client receives when it sends a
        GET request to the URL.

!!!!    A collection resource is a little more specific than that. It exists mainly to group other
        resources together. Its representation focuses on links to other resources, though it may
        also include snippets from the representations of those other resources. (Or even the
        full representations!)

    Collections Link to Items
        An individual resource contained within a collection is sometimes called an item, an
        entry, or a member of the collection. Think about the contact list on your friend’s phone.
        You show up in that list: your name and your phone number. You’re an item in the
        “contact list” collection.

        When we talk about an “item” or an “entry” or a “member,” we’re talking about a standalone
        resource that happens to be linked to from a collection’s representation.

    Collection+JSON
        Here’s a Collection+JSON document:
        {
        	"collection":{
        		"version":"1.0",
        		"href":"http://www.youtypeitwepostit.com/api/",
        		"items":[
        			{
        				"href":"/api/messages/21818525390699506",
        				"data":[
        					{
        						"name":"text",
        						"value":"Test."
        					},
        					{
        						"name":"date_posted",
        						"value":"2013-04-22T05:33:58.930Z"
        					}
        				],
        				"links":[

        				]
        			},
        			{
        				"href":"/api/messages/3689331521745771",
        				"data":[
        					{
        						"name":"text",
        						"value":"Hello."
        					},
        					{
        						"name":"date_posted",
        						"value":"2013-04-20T12:55:59.685Z"
        					}
        				],
        				"links":[

        				]
        			}
        		],
        		"links":[
        			{
        				"href":"/logo.png",
        				"rel":"icon",
        				"render":"image"
        			}
        		],
        		"queries":[
        			{
        				"href":"/api/search",
        				"rel":"search",
        				"prompt":"Search the microblog archives",
        				"data":[
        					{
        						"name":"query",
        						"value":""
        					}
        				]
        			}
        		],
        		"template":{
        			"data":[
        				{
        					"prompt":"Text of message",
        					"name":"text",
        					"value":""
        				}
        			]
        		}
        	}
        }

        It’s basically an object with five special properties, predefined slots for applicationc specific data:
            href
                A permanent link to the collection itself.
            items
                Links to the members of the collection, and partial representations of them.
            links
                Links to other resources related to the collection.
            queries
                Hypermedia controls for searching the collection.
            template
                A hypermedia control for adding a new item to the collection.

    Representing the Item
        "items":[
        	{
        		"href":"/api/messages/21818525390699506",
        		"data":[
        			{
        				"name":"text",
        				"value":"Test."
        			},
        			{
        				"name":"date_posted",
        				"value":"2013-04-22T05:33:58.930Z"
        			}
        		],
        		"links":[

        		]
        	},
        	{
        		"href":"/api/messages/3689331521745771",
        		"data":[
        			{
        				"name":"text",
        				"value":"Hello."
        			},
        			{
        				"name":"date_posted",
        				"value":"2013-04-20T12:55:59.685Z"
        			}
        		],
        		"links":[

        		]
        	}
        ]

        I say it’s the most important field because it makes it clear which items are in the col‐
        lection. In Collection+JSON, each member is represented as a JSON object. Like the
        collection itself, each member has a number of predefined slots that can be filled with
        application-specific data:
            The href attribute
                A permanent link to the item as a standalone resource.
            links
                Hypermedia links to other resources related to the item.
            data
                Any other information that’s an important part of the item’s representation.

        An item’s permanent link
            You might be able to modify an item with HTTP PUT to its permanent link, or delete
            it with HTTP DELETE. These are the item’s protocol semantics. They’re spelled out as
            part of Collection+JSON’s definition of an “item.”

        An item’s data
            At the core of any Collection+JSON application are the application-level semantics
            you’re trying to convey: the bits of data associated with each individual item. Most of
            this data goes into an item’s data slot. That slot needs to contain a list of JSON objects,
            each with the properties name and value, each describing a single key-value pair.

            "data":[
            	{
            		"name":"text",
            		"value":"Test.",
            		"prompt":"The text of the microblog post."
            	},
            	{
            		"name":"date_posted",
            		"value":"2013-04-22T05:33:58.930Z",
            		"prompt":"The date the microblog post was added."
            	}
            ]

            The name attribute is the key of the key-value pair, the value is of course the value, and
            the (optional) prompt is a human-readable description. The Collection+JSON standard
            says nothing about what keys, values, or prompts you should use

        An item’s links
            The simplest of Collection+JSON’s hypermedia controls is the href attribute. I covered
            this earlier; it’s a special link that provides a URL the client should use whenever it wants
            to refer to one specific item:
                "href" : "/api/messages/21818525390699506"

            An item’s representation may also contain a list called links. This contains any number
            of other hypermedia links to related resources. Here’s a link you might see in the rep‐
            resentation of a “book” resource:
                {
                 "name" : "author",
                 "rel" : "author",
                 "prompt" : "Author of this book",
                 "href" : "/authors/441",
                 "render" : "link"
                }

            That’s approximately equivalent to this snippet of HTML:
                <a href="/authors/441" id="author" rel="author">Author of this book</a>

            The rel attribute is a slot for a link relation, just like the rel attribute in Maze+XML.
            It’s a place for you to put some application semantics. The prompt attribute is a place to
            put a human-readable description, like the link text inside an HTML <a> tag

            Setting render to "link" tells a Collection+JSON client to present the link as an outbound link
            (see Chapter 4), like an HTML <a> tag.
            Setting render to "image" tells the client to present the link as an embedded image, like
            HTML’s <img> tag.


    The Write Template
        Suppose you want to add a new item to a collection. What HTTP request should you
        make? To answer this question, you need to look at the collection’s write template.

        Here’s the write template for our microblogging API:
            "template": {
             "data": [
                {"prompt" : "Text of message", "name" : "text", "value" : ""}
             ]
            }
        Interpreting this template according to the Collection+JSON standard tells you it’s OK
        to fill in the blanks and submit a document that looks like this:
            { "template" :
             {
                "data" : [
                    {"prompt" : "Text of the message", "name" : "text", "value" : "Squid!"}
                ]
             }
            }

        Where does that request go? The Collection+JSON standard says you add an item to a
        collection by sending a POST request to the collection (i.e., to its href attribute):
            "href" : "http://www.youtypeitwepostit.com/api/",

        That means the write template is conceptually equivalent to this HTML form:
            <form action="http://www.youtypeitwepostit.com/api/" method="post">
                <label for="text">Text of the message</label>
                <input id="text"/>
                <input type="submit"/>
            </form>

        It’s not exactly the same, because filling out the HTML form sends an application/xwww-form-urlencoded
        representation, and filling out a write template sends an application/vnd.collection+json representation.
        But conceptually, those two hypermedia controls are very similar.

    Search Templates
        If a collection has millions of items, it would be foolish for the server to send represen‐
        tations of all of them to every client that makes a GET request. The server can avoid this
        by providing search templates—hypermedia forms that the client fills out to filter a
        Collection+JSON collection.

        The search templates for a collection are stored in the queries slot. Here’s a queries
        slot that includes a simple search template:
            {
             "queries" :
             [
             {
             "href" : "http://example.org/search",
             "rel" : "search",
             "prompt" : "Search a date range",
             "data" :
             [
             {"name" : "start_date", "prompt": "Start date", "value" : ""},
             {"name" : "end_date", "prompt": "End date", "value" : ""}
             ]
             }
             ]
            }

    How a (Generic) Collection Works
        There’s not much more to Collection+JSON than what I’ve just shown. It was designed
        without any real application semantics, so that it can be used in many different appli‐
        cations. Because it’s so general, it does a good job illustrating the common features of
        the collection pattern.

        GET
            Like most resources, a collection responds to GET by serving a representation. Although
            the three main collection standards don’t say much about what an item should look like
            within a collection, they go into great detail about what a collection’s representation
            should look like.
            The media type of the representation tells you what you can do with the resource. If you
            get an application/vnd.collection+json representation, you know that the rules of
            the Collection+JSON standard apply. If the representation is application/atom+xml,
            you know that AtomPub rules apply

        POST-to-Append
            The defining characteristic of a collection is its behavior under HTTP POST. Unless a
            collection is read-only (like a collection of search results), a client can create a new item
            inside it by sending it a POST request.
            That resource becomes the latest member of the collection.
            Recall Chapter 2, when a POST sent to the microblog API created a new entry “inside” the microblog.

        PUT and PATCH
            None of the main collection standards define a collection’s response to PUT or PATCH.
            Some applications implement these methods as a way of modifying several elements at
            once, or of removing individual elements from a collection.
            Collection+JSON, AtomPub, and OData all define an item’s response to PUT: they say
            that PUT is how clients should change the state of an item. But these standards are just
            repeating what the HTTP standard says. They’re not putting new restrictions on item
            resources. PUT is how clients change the state of any HTTP resource.

        DELETE
            None of the three big standards define how a collection should respond to DELETE.
            Some applications implement DELETE by deleting the collection; others delete the col‐
            lection and every resource listed as an item in the collection.

        Pagination
            A collection may contain millions of items, but again, the server is under no obligation
            to serve millions of links in a single document. The most common alternative is pagi‐
            nation. A server can choose to serve the first 10 items in the collection, and give the
            client a link to the rest:
                <link rel="next" href="/collection/4iz6"/>
            The "next" link relation is registered with the IANA to mean “the next in the series.”
            Follow that link and you’ll get the second page of the collection. You’ll probably be able
            to keep following rel="next" links indefinitely, until you reach the end of the collection.

!!!!        There are a number of generic link relations for navigating paginated lists. These include
            "next", "previous", "first", "last", and "prev" (which is a synonym for “previous”).
            These link relations were originally defined for HTML, but now they’re registered with
            the IANA, so you can use them with any media type.

        Search Forms
            The final common feature of the collection pattern is the hypermedia search form. This
            also helps with very large collections. Search forms let a client find the interesting parts
            of a collection without downloading the whole thing.
            Collection+JSON and OData explicitly define their own formats for hypermedia search
            forms. I showed you a Collection+JSON search template earlier in this chapter.

    The Atom Publishing Protocol (AtomPub)
        The Atom file format was developed as an alternative to RSS for syndicating news articles
        and blog posts. It’s defined in RFC 4287, which was finalized in 2005. The Atom Pub‐
        lishing Protocol is a standardized workflow for editing and publishing news articles,
        using the Atom file format as the representation format.

        AtomPub has the same concepts as Collection+JSON, but uses different
        terminology. Instead of a “collection” that contains “items,” this is a “feed” that contains
        “entries.”

        is served with the media type application/atom+xml

        You know you can POST a new Atom entry to the href of the collection. An entry’s rel="edit" link is the
        URL you send a PUT to if you want to edit the entry, or send a DELETE to if you want to delete the entry.

        There’s one big conceptual difference between Collection+JSON and AtomPub. Col‐
        lection+JSON defines no particular application semantics for “item.” An “item” can look
        like anything. But since Atom was designed to syndicate news articles, every AtomPub
        entry looks a bit like a news article.

!!!!    Google, the biggest corporate adopter of AtomPub, uses Atom
        documents to represent videos, calendar events, cells in a spreadsheet, places on a map,
        and more.
        Google defined a common Atom extension
        called GData for all of its Atom-based APIs, then defined additional extensions for
        videos, calendars, spreadsheets, and so on.

        AtomPub defines a separate media type for a list of categories (application/atomcat+xml).

        AtomPub also defines a media type for a Service Document—effectively a collection of collections.

 !!!!   Even if you’re not using AtomPub, you can benefit from the work done by the people
        who’ve spent the past several years working on Atom extensions. They’ve created a
        standard vocabulary for a lot of common operations; you just have to decide to reuse it.

    Why Doesn’t Everyone Use AtomPub?
        The standard never got much traction outside of Google, and even Google seems to be phasing it out.
        What’s wrong with AtomPub?
        The problem stems from a technical decision made back in 2003: AtomPub represen‐
        tations are XML documents. This seemed like the obviously correct decision in 2003,
        but over the next 10 years, as in-browser API clients became more and more popular,
        JSON gained an overwhelming popularity as a representation format

        Today, the vast majority of APIs either serve JSON representations exclusively, or offer a choice
        between XML and JSON representations. AtomPub is nowhere to be seen.2

!!!!    But the AtomPub story also shows that “nothing wrong with the standard” isn’t good
        enough. People won’t go through the trouble of learning a standard unless it’s directly
        relevant to their needs. It’s easier to reinvent the “collection” pattern using a fiat standard
        based on JSON, so that’s what thousands of developers did—and continue to do.

!!!     I don’t know whether the answer is Collection+JSON or any of the other hypermedia formats
        I cover in the next few chapters. There’s probably no single answer.
        I do know that the “collection” pattern has proven itself dominant. The question is
        whether we’ll collectively allow ourselves to reinvent the same basic ideas over and over again.

    The Semantic Challenge: How Are We Doing?
        Remember, the semantic challenge is: How can we program a computer to decide which
        links to click? To answer this question, we must bridge the gap between the protocol
        semantics of HTTP (generic “resources” identified by URLs and responding to methods
        like GET and PUT) and the application semantics of your special, unique web API (a
        microblogging service, a payment processor, or whatever it is you’re doing).

        A domain-specific design like Maze+XML bridges the gap with a custom-designed hy‐
        permedia type, plus link relations defined especially for your problem space. But that’s
        a lot of work, and almost nobody goes that far. ()

        The collection pattern recognizes two different kinds of resources: item-type resources
        (which tend to respond to GET, PUT, and DELETE) and collection-type resources
        (which tend to respond to GET and POST-to-append). A collection-type resource
        contains a number of item-type resources. Its representation links to those items and
        includes partial representations of them

!!!!    But an "item" still isn’t anything in particular. It’s almost as vague a term as “resource.”
        In a microblogging API, an "item" will be a bit of text with a timestamp. In a payment
        processor, an "item" will include a creditor, a debitor, a method of payment, and an
        amount of money. There’s still an enormous gap between the application semantics of
        the collection pattern and the application semantics of your individual API.

        If everyone used Collection+JSON for their APIs, we would all share a common defi‐
        nition of “collection”. But there’d be 57 different definitions of “item”, 57 sets of data
        elements with differing values for prompt. Some APIs would call the text field "text";
        others would call it "content" or "post" or "blogPost", and they’d all describe the
        same thing in different words. We’d still have 57 different microblogging APIs.
!!      So we’re still not there. We still need something more.

===============================================================================================================
===============================================================================================================
Chapter  7 - Pure-hypermedia designs

!!!!Nothing says you have to use the collection pattern, but it is the most popular design
    pattern for APIs. If you want to implement some other pattern, or if your API design
    doesn’t fit any particular pattern, you can describe an API’s semantics using pure hy‐
    permedia. You don’t have to create an entirely new standard like Maze+XML, with its
    own media type. You can represent the state of your resources using a generic hypermedia language.

    Why HTML?
        We think of HTML in the context of the World Wide Web: a network of documents
        intended to be read by human beings. That popularity makes it the obvious choice for
        any part of an API that serves documents intended for human consumption. Even if
        the rest of your API serves XML- or JSON-based representations, you can use HTML
        for the parts that will be rendered to a human user. Such is HTML’s popularity that every
        modern operating system ships with a tool for debugging HTML-based web APIs: a
        web browser.

!!!!!   HTML has distinct advantages even for an API designed to be consumed entirely by
        machines. HTML imposes more structure on a document than XML or JSON does, but
        not so much structure as to solve only one specific problem, the way Maze+XML does.
        HTML sits somewhere in the middle, like Collection+JSON.

!!      Unlike bare XML or JSON, HTML comes packaged with a standardized set of hyper‐
        media controls. But HTML’s controls are very general, and not bound to a specific
        problem space. Collection+JSON defines a special hypermedia control for search quer‐
        ies; HTML defines a hypermedia control (the <form> tag) that can be used for any purpose at all.

        Because HTML is so popular, it’s the base standard for two enormous, ongoing efforts to bridge the
        semantic gap: microformats and microdata, which I’ll cover later in this chapter.

        HTML documents can include the same basic data structures as you find in JSON.
        Ordered lists use the <ol> tag, and sets of key-value pairs use the <dl> tag. (It’s called
        “dl” because HTML calls that data structure a “definition list.”)
        HTML also supports unordered lists (the <ul> tag), two-dimensional arrays (the
        <table> tag), and arbitrary ways of grouping tags together (using the <div> and <span>
        tags) without regard to standard data structures

    Hypermedia Controls
!!!!    More important, HTML has built-in hypermedia controls. I mentioned these controls
        back in Chapter 4, but just to recap, here are the most important ones:
            • The <link> tag and <a> tag are simple outbound links, like the <link> tag in Maze
            +XML. They tell the client to make a GET request to a specific URL in order to get
            a representation. That representation becomes the current view.
            • The <img> tag and <script> tags are embedding links. They tell the client to au‐
            tomatically make a GET request to another resource, and to embed the represen‐
            tation of that resource in the current view.
            • When the <form> tag has the string "GET" as its method attribute (i.e. <form meth
            od="GET">), it acts as a templated outbound link. This works like a URI Template,
            or the queries slot in Collection+JSON. The server provides the client with a base
            URL and some input fields (HTML <input> tags). The client plugs in values for
            those fields, combines them with the base URL to form a one-of-a-kind destination
            URL, and makes a GET request to that URL.
            • When the <form> tag has "POST" as its method attribute, it describes an HTTP POST
            request that can do anything at all. The <input> tags are still present, but instead
            of being used to create the request URL, they’re used to create an entity-body with
            the media type application/x-www-form-urlencoded. The request URL is hard‐
            coded in the action attribute of the <form> tag

    Plug-in Application Semantics
        HTML 4 defines three generic attributes that we can use to
        add application-level semantics not defined in the HTML standard. (HTML 5 defines
        a few more, which I’ll cover later.)

        The rel attribute
            HTML’s <a> and <link> tags have an attribute called rel, which defines the relationship
            between the resource being linked to and this one. We’ve seen rel before:
            <link rel="stylesheet" type="text/css" href="/my_stylesheet.css"/>
            That bit of HTML says that the resource /my_stylesheet.css should be retrieved and
            automatically used to style the current page. In this context, HTML’s <link> tag serves
            as an embedding link. With a different value for rel (say, rel="self") the <link> tag
            would serve as an outbound link

            Although there are standard lists of link relations (like the IANA registry I mentioned
            in Chapter 5), there’s nothing special about the strings “stylesheet” or “self ”. Someone
            made them up for HTML. If you’re publishing a maze API in HTML, you can adopt the
            link relations defined in Maze+XML ("north", "south", and so on). Use them in an
            HTML document. This will give the HTML format some application-level semantics it
            didn’t have before

            The disadvantage of making up your own link relations is that your users will have no
            idea what those relationships mean. You’ll need to document these bits of application
            semantics in a profile (see Chapter 8).

        The id attribute
            Almost any HTML tag can define a value for the id attribute. This attribute uniquely
            identifies an element within a document:
                <div id="content">
            If you happen to be looking for the tag with id="content", well, here it is. An HTML
            document can’t contain two elements with the same ID.
!!          I don’t recommend using the id attribute as a hook for your application-level semantics.
            The requirement that IDs be unique across a document is too limiting. It creates situa‐
            tions where two HTML documents can’t be combined into a larger document, because
            they both define the same id

!!!     The class attribute
            On the World Wide Web, class is usually used to apply
            CSS formatting, but it can also be used to convey something about a tag’s application
            semantics; literally, what “class” it belongs to.:
            Here’s a simple example of a <div> tag that contains two <span> tags:
                <div class="vcard">
                 <span class="fn">Jennifer Gallegos</span>
                 <span class="bday">1987-08-25</span>
                </div>

            But suppose I tell you that the "vcard" class
            groups together information about a human being (for the moment, don’t worry about
            how I tell you this; I’ll cover that later). I tell you that a tag marked with the "fn" class
            contains the person’s name, and a tag marked with the "bday" class contains the person’s
            date of birth in ISO 8601 format

            Now the <div> tag is a description of a person. Now it means something

            If you’re ever tempted to use id for a piece of application semantics, I recommend using
            class instead. Unlike with id, many tags in a representation can have the same class
            attribute.

    Microformats
        I chose some pretty cryptic CSS class names to turn a <div> tag and a couple <span>
        tags into a description of a human being: “vcard,” fn, and bday. If I’d made up those
        class names myself, I’d have used more descriptive names like birthday. But I didn’t
        make them up. I took them from an existing standard called hCard. If you ever see
        class="vcard" on an HTML tag, you’ll know that everything inside that tag should be
        interpreted according to the hCard standard.

!!!!    hCard is a microformat: a lightweight industry standard defined through informal collaboration on a
        wiki, rather than through the formal IETF process that results in RFCs.

        Microformats let you add extra application semantics to HTML. HTML’s class at‐
        tribute, plus the hCard microformat, lets you create an HTML document that’s also a
        description of a human being

!!!     hCard only defines values for the class attribute. The <span> and <div> tags I used
        mean nothing to hCard; I could have used other tags
            <p class="vcard">My name is <i class="fn">Jennifer Gallegos</i> and I
            was born on <date class="bday">1987-08-25</date>.</p>

        A human being will read this representation as an English sentence. An hCard processor
        will ignore all the “extraneous” text and focus on the tags that use hCard’s CSS classes.

        Although the hCard microformat didn’t go through a formal standardization process,
        it’s based on a standard that did: vCard, a heavyweight plain-text format for representing
        business cards, defined in RFC 6350.
        We can steal vCard’s semantics and adapt them to a generic hypermedia language: HTML.

    The hMaze Microformat
        In this section, I’ll do to Maze+XML what hCard did for vCard. I’ll take a non-HTML
         standard designed for a specific domain—mazes—and turn it into an HTML micro‐
         format  (he basically translates the Maze+XML to HTML)

!!      I’m calling my new microformat “hMaze,” by analogy with “hCard.” (The “h” stands for
        “HTML.”) My microformat defines a few special CSS classes:

        This microformat can represent any maze Maze+XML can represent, but in HTML

        My microformat only defines values for class and rel. As with hCard, the choice of
        tags is left to the server.

    Microdata
!!!!    Microdata is a refinement of the microformat concept for HTML 5. You see, microfor‐
        mats are kind of a hack. HTML’s class attribute was designed to convey information
        about visual display (via CSS), not to convey bits of application semantics

        HTML Microdata introduces five new attributes specifically for representing appli‐
!!!     cation semantics: itemprop, itemscope, itemtype, itemid, and itemref. These at‐
        tributes may appear on any HTML tag.

        The itemprop attribute is used the
        way a microformat uses the class attribute. The itemscope attribute is a Boolean at‐
        tribute, used on a tag to indicate that the tag contains microdata. And the itemtype
        attribute is a hypermedia control that tells the client where it should go to find out what
        the microdata means.

        Here’s an HTML document that presents a microdata type that’s a slight
        variant of hMaze:
            <div itemscope itemtype="http://www.example.com/microdata/Maze">
             <div itemprop="cell">
                 <div itemprop="title">
                    Hall of Pretzels
                 </div>
                 <div>
                     <a href="/cells/143" rel="west"/>
                     <a href="/cells/145" rel="east"/>
                 </div>
             </div>
            </div>

        The itemscope property indicates that everything beneath this tag is described according to the rules
        laid out in some document, and itemtype points to that document
            (THE DOCUMENT at the other end of the itemtype URL)

!!!     A microformat does have one advantage over a microdata item. A microdata item can‐
        not define any values for the rel attribute—only for itemprop. This means that
        rel="east" and rel="west" are not technically part of my hMaze-like microdata item.
        The document at http://www.example.com/microdata/Maze will probably mention that
        a client can expect to see rel="east" and rel="west" in representations of maze cells.
        But as far as the microdata standard is concerned, there’s no relationship. You can’t
        define link relations in a microdata item.

!!      The main source of microdata items is schema.org, a project of four big search engines
        (Bing, Google, Yahoo!, and Yandex) to define application semantics for different prob‐
        lem domains. Search engines have an interest in understanding the high-level applica‐
        tion semantics of a web page—that is, whatever real-world thing the web page is talking
        about.

!!!!    you’ll start seeing examples that refer to schema.org microdata items. To a
        human being, it should be pretty obvious what they mean. The URL http://schema.org/
        Person points to the schema.org microdata item corresponding to our everyday notion
        of a “person.”

    Adding Application Semantics to Forms
        The hMaze microformat defines values for HTML’s rel attribute that give new appli‐
        cation semantics to HTML links. When you notice that an ordinary-looking HTML
        link has its rel set to east, it stops being an ordinary link and becomes a passage through
        a geographical space.

!!      HTML links only support the GET method, and I can’t use GET because “flip a switch” is not a safe operation.
        It modifies resource state.
        That’s the whole point. The position of the switch used to be off, and now it’s on. The
        exit to the maze used to be in cell C, and now it’s in cell J.

        Fortunately, HTML also defines hypermedia forms. An HTML form can tell the client
        to make a POST request, and a POST request can do anything at all.

        Now it’s clear how to flip a switch. You look inside the tag with class="switch", find
        the form submission control with class="flip", and activate that control. Here’s the
        representation of the Hall of Pretzels again:
            <div class="hmaze">
             <div class="cell">
                <p>
                    <b class="title">
                        <a href="/cells/H" rel="current">Hall of Pretzels</a>
                    </b>
                </p>
                <ul>
                    <li><a href="/cells/G" rel="east">Go west</a></li>
                    <li><a href="/cells/I" rel="west">Go east</a></li>
                </ul>
                <div class="switch">
                    A mysterious switch is mounted on one wall. The switch is <span class="position">up</span>.
                    <form action="/switches/4" method="post">
                        <input class="flip" type="submit" value="Flip it!"/>
                    </form>
                </div>
              </div>
             </div>

        I could add features to this game all day, but I think this shows how I go about defining
        a set of application semantics that can be used with a general hypermedia format like
        HTML. Here’s the entire hMaze microformat in one place. I define seven CSS classes
        that can apply to any tag at all:

            hmaze
                Indicates the parent tag of an hMaze document. Analogous to hCard’s vcard class.
            collection
                May appear within hmaze. Contains a collection of mazes.
            error
                May appear within hmaze. Indicates an error message.
            cell
                May appear within hmaze. Describes a cell in a maze.
            title
                May appear within cell. Contains the name of the cell.
            switch
                May appear within cell. Describes a switch found in the maze.
            position
                May appear within switch. Describes the position of the switch. There are two positions: up and down.
            I define eight link relations, which only apply to hypermedia controls: maze, start,
            north, south, east, west, current, and exit. These relations have the same meaning
            in hMaze as they do in Maze+XML.

            flip
                May appear on a form submission control within switch. When activated, the con‐
                trol will have the effect of flipping the switch.

!!!     And that’s the API. Specifically, that’s the specification for an API, a personal standard
        with the same standing as Maze+XML. There are a couple loose ends, things I didn’t define:
!!!!        What exactly should the HTML documents look like? I didn’t define this because I
            don’t care. Your hMaze implementation can serve full human-readable documents
            with lots of flavor text, or it can serve very compact documents optimized for au‐
            tomated clients. As long as you use the hMaze CSS classes and link relations cor‐
            rectly, your choice will have no effect on the application semantics of the maze.

    The Alternative to Hypermedia Is Media
!!!!    I think it’s useful to contrast the hMaze specification with what passes for API docu‐
        mentation today. In typical API documentation, a bunch of server-side methods are
        exposed as discrete API calls. Each call is given its own action URL and documented in
        excruciating detail. You’ve probably seen this sort of thing before:
        To flip a switch, send a POST request to:
            http://api.example.com/switches/{id}?action=flip
            Where {id} is the switch ID.
        You can only flip a switch if you are in the same cell as the switch.

!!!     If you find yourself writing up (or generating) documentation like this example, you’re
        using human-readable documentation as a substitute for hypermedia. That’s unacceptable.
        You’re creating useless work for yourself and your users.

        Certainly the server must provide that information somehow. The client needs to know
        exactly what HTTP request to send, and approximately what will happen if it sends that
        request. But almost all of this information can be written for its intended audience—a
        piece of software—and served when needed. You don’t need to spell it out in English
        ahead of time.

!!      By contrast, here’s my machine-readable explanation of how to flip the mysterious
        switch:
            <div class="switch">
                A mysterious switch is mounted on one wall. The switch is <span class="position">down</span>.
                <form action="/switches/4" method="post">
                    <input class="flip" type="submit" value="Flip it!"/>
                </form>
            </div>

        That takes care of the protocol semantics. It explains exactly what HTTP request the
        client can make to trigger the state transition flip. The only human-readable docu‐
        mentation I need to provide is the hMaze spec, which defines the application semantics of flip:

!!!!    I don’t have to provide a template for constructing the action URL, or force the client
        to reckon with my internal concept of a “switch ID,” because the <form> tag for flipping
        a switch includes the actual URL the client should use. I don’t have to make caveats like
        “You can only flip a switch if you’re in the same cell as the switch,” because hypermedia
        controls are presented only when they can be used. If the submit button isn’t there, the
        state transition isn’t available

!!        I used to think that you should design APIs by identifying the resources and tying them
        together with hypermedia. This resource-oriented approach is good advice when you’re
        trying to move away from publishing all your internal methods as a huge list of API
        calls. Thinking in terms of resources will at least group the API calls together in sensible ways.

!!!     But in a hypermedia-based design, resources don’t matter as much. The designer’s job
        is to identify all the state transitions. A resource-oriented design would focus heavily
        on the mysterious switch as a resource, as a thing in itself. But the switch itself isn’t all
        that important. My design focuses on the state transition, on what you can do with the
        switch.

    HTML’s Limits
        Technically, HTML is a domain-specific standard, not a general hypermedia format.
        I’m covering it here instead of in Chapter 5 because HTML’s “domain” is a very general
        one: human-readable documents. It’s fine to use HTML for other purposes, like maze
        games played by robots, but you will quickly run into the limits of the data format.

!!!     • HTML includes a lot of hypermedia controls, but the controls can’t describe all of
        HTTP’s protocol semantics. There’s no way to tell an HTML client to make a PUT
        or DELETE request without using JavaScript.
        • Forms in HTML 4 can only build entity-bodies in two different formats: either
        application/x-www-form-urlencoded (for basic key-value pairs) or multipart/
        form-data (for key-value pairs plus file uploads
        • Unlike JSON, HTML 4 doesn’t distinguish between strings and numbers. Any string
        within an HTML tag is assumed to be just that—a string. If you want to say that a
        string should be interpreted in some other way, you’ll need to specify that yourself,
        outside of the HTML document
        • HTML 4 doesn’t define a way of representing dates (JSON has the same problem).
        When the vCard standard defines the bday class, it says that any data provided for
        bday should be interpreted as a date in ISO 8601 format. Without that extra infor‐
        mation (presented in human-readable form), there’s no way to know for sure
        whether "1987-08-25" is a date, or just a string that happens to look like a date.

    HTML 5 to the Rescue?
        The new HTML 5 standard6 solves some of HTML 4’s problems:
            • HTML 5 defines the time tag, which can be used to represent a date or timestamp
            in a specific format.
            • There are a few cases where you can use HTML 5’s meter tag to represent a number,
            but it doesn’t work in general.
            • HTML 5 offers a few new hypermedia controls for creating embedded links, in‐
            cluding: <audio>, <video>, <source>, and <embed>. None of them are terribly useful
            in APIs, unless part of the API’s job is delivering multimedia to human beings
            • HTML 5 defines several new options for validating input tags. An input tag can
            specify that it wants a date, a number, or a url as input. An input tag can be marked
            as required, meaning that the form can’t be submitted without providing a value
            for the field. An HTML 5 client can use this information to do client-side validation

!!!!    In summary, HTML 5 offers some useful new features, but it doesn’t drastically change
        HTML as a hypermedia format

    The Hypertext Application Language (HAL)
        Several new hypermedia formats have emerged in reaction to HTML, formats designed specifically for
        use in web APIs. The Hypertext Application Language (HAL) is a new format that takes
        the fundamental concept of HTML—the hyperlink—and ruthlessly prunes away ev‐
        erything else. I think it prunes too much, but it’s a good example of a general hypermedia
        language that doesn’t have HTML’s historical baggage. Let’s see how it works.

        HAL comes in two flavors: one that uses XML (media type: application/hal+xml) and
        one that uses JSON (media type: application/hal+json). I’ll call them HAL+XML and
        HAL+JSON for short.7 The two are formally identical, but I’m going to focus on HAL
        +XML, because I think it’s easier to look at a HAL+XML document and see what’s going on.

        Here’s a HAL+XML document I made up, a representation from a hypothetical HAL
        version of the maze game. It represents a maze cell in more or less the same way as
        hMaze. It includes a number of links to other cells, and a switch that can be flipped:

            <resource href="/cells/H">
                <title>Hall of Pretzels</title>
                <link href="/cells/G" rel="east"/>
                <link href="/cells/I" rel="west"/>
                <resource href="/switches/4">
                    <switch>
                        <position>up</position>
                        <link href="/switches/4" rel="flip" title="Flip the mysterious switch."/>
                    </switch>
                </resource>
            </resource>

        HAL only defines two concepts: resources and links. HAL+XML represents these as
        <resource> and <link> tags. All the other tags in that document are application-specific
        tags I made up, based on hMaze.

        The <resource> tag just says that the XML inside the tag is a representation of some
        HTTP resource.

!!!     The <link> tag is a completely generic hypermedia control. This is the big difference,
        hypermedia-wise, between HAL and HTML. HTML has different controls for different
        purposes. The <a> tag makes a GET request when activated, and when it gets a document
        in response, the application’s focus moves to that document. The <img> tag makes a GET
        request automatically and embeds the resulting representation as an image in the cur‐
        rent document, without changing the application’s focus. The <form> tag can be set up
        to make either a POST request or a GET request. But there’s no HTML tag that can
        trigger a PUT or DELETE request. If you want to describe an HTTP request using
        HTML, but the W3C didn’t define a tag that does what you want, you’re out of luck.

        HAL has only one hypermedia control, but that control can do anything. It can trigger
        a GET request, a POST request, or a PUT request with a specific entity-body. It can offer
        the user a choice between DELETE and UNLINK. The <link> tag in a HAL+XML
        document can trigger any HTTP request at all when activated.

        Let’s take a look at just the links in my HAL+XML document:
            <link href="/cells/G" rel="east"/>
            <link href="/cells/I" rel="west"/>
            <link href="/switches/4" rel="flip" title="Flip the mysterious switch."/>
!!!!    This is why I think HAL strips too much away from HTML. How are you supposed to
        know which of the infinite possibilities are present in a given link? The <link> tag with
        rel="east" should trigger a GET request that gives you a representation of the cell to
        the east. The <link> tag with rel="flip" should trigger a POST request that flips the
        switch. One of them is a safe operation that modifies application state; the other is an
        unsafe, non-idempotent operation that modifies resource state. In HAL, those two links
        look almost identical. The only real difference is the link relation.

        When I define rel="flip", I’m supposed to mention that the flip state transition is triggered with a
        POST request. This means writing some human-readable documentation like this:
            flip
        May appear within switch. When activated with a POST request, will have the effect of flipping the switch.
        Do you see the problem? The API’s protocol semantics are creeping out of machine readable hypermedia and into
        human-readable text

!!      But HAL has no way of conveying protocol semantics in a machine-readable way. I have to spell it out in the
        docs, and everyone who implements a maze client has to read my docs and program the protocol semantics into
        their client.

    Siren
        I’ll close out this chapter by taking a brief look at another general hypermedia format: Siren.
        Siren is a newer format than HAL, and although it’s based on JSON, it takes a
        more HTML-like approach to hypermedia than HAL’s minimalism.

        Here’s a sample Siren document—a representation of the maze cell you’ve already seen
        in HTML and HAL formats:
        {
             "class" : ["cell"],
             "properties" : { "title": "Hall of Pretzels" },
             "links" : [
                { "rel" : ["current"], "href" : "/cells/H" },
                { "rel" : ["east"], "href" : "/cells/G" },
                { "rel" : ["west"], "href" : "/cells/I" }
             ],
             "entities" : [
                { "class" : ["switch"],
                  "href" : "/switches/4",
                  "rel" : ["item"],
                  "properties" : { "position" : ["up"] },
                  "actions" : [
                     { "name" : "flip",
                        "href" : "/switches/4",
                        "title" : "Flip the mysterious switch.",
                        "method": "POST"
                     }
                 ]
                }
             ]
        }

 !!!!   Siren is designed to represent abstract groupings of data it calls entities. A Siren “entity”
        is conceptually similar to HTML’s <div> tag. It’s a convenient way of splitting up your
        data. An entity may be an HTTP resource with its own URL, but it doesn’t have to be.

        The flip state transition is defined by a Siren action, a hypermedia control analogous
        to an HTML form. (Note the method, just like an HTML form.) The name of the Siren
        action serves the same purpose as the class of an HTML form, or the rel of a link. It
        makes it clear which state transition will happen if the client decides to activate the
        control. The purpose of the state transition—to flip the switch—still needs to be de‐
        scribed in human-readable text. I put this text in the title attribute.

        The Siren standard requires that every subentity provide a rel describing
        the relationship between its parent and itself. The item link relation is an IANA registered relation describing
        the relationship between a collection (the cell) and the things it contains (such as mysterious switches).

        Siren sits somewhere between HTML and Collection+JSON.

        The upside of this approach is greater flexibility in representing state transitions that
        don’t fit the collection pattern. The downside is that two Siren applications (or two
        HTML applications) will have less in common, and require more special client-side
        programming, than two Collection+JSON applications.

    The Semantic Challenge: How Are We Doing?
!!!     We have a client-server Internet protocol, HTTP, which assigns very general meanings to different kinds of
        requests: GET, POST, PUT, and so on.

!!!!    We have the idea of hypermedia, which allows the server to tell the client which HTTP
        requests it might want to make next. This frees the client from having to know the shape
        of the API ahead of time.

        And we have a whole lot of standards for building APIs

        We have domain-specific standards like Maze+XML, which define the application-level
        semantics and the protocol-level semantics for one tiny problem space (like maze
        games).

        We have standards like Collection+JSON and the Atom Publishing Protocol, which see
        the world in terms of “collection” and “item” resources

        We have microformats like hCard, and microdata items like schema.org’s http://sche
        ma.org/Person. These define a lot of application-level semantics for explaining what a
        document means, but little or no protocol semantics for explaining how the underlying
        resource should behave under HTTP.

        And we have standards like HTML, HAL, and Siren, languages that give you free rein
        to define your own protocol semantics and your own application-level semantics.

        If the API is described by a domain-specific standard like Maze+XML, bridging the
        semantic gap is straightforward. All the information you need is in the standard. It
        explains both the protocol semantics and the application semantics. You read the stan‐
        dard, you decide how your client should respond in any given situation, and you write
        your client.

        But domain-specific hypermedia standards are rare. Most hypermedia APIs use col‐
        lection standards like AtomPub, or generic hypermedia languages like HTML. These
        standards define an API’s protocol semantics, but they don’t say much about the appli‐
        cation semantics. A human being must read some other document to understand the
        meanings encoded in the representations the API is serving


        But where is that document? Does the API use a microformat? Which microformat?
        How do you find out? Are you just supposed to know about all the microformats?
        What if the API doesn’t use HTML? Siren has no support for microformats or microdata.
        What if an API designer wants to put hCard-like data in a Siren document?

        At this point, we reach the limits of current technology. There are no well-accepted
        answers to these questions. The result is that every API designer simply makes up
        application-level semantics that fit with their preexisting server-side design, and docu‐
        ments those semantics… somewhere.

        This is how we ended up with 57 microblogging APIs. We’re stuck. API technology can’t
        advance beyond the “hypermedia” state without answering these questions.

===============================================================================================================
===============================================================================================================
Chapter 8 - Profiles

!!!!!   Over the past three chapters, I’ve built up a set of rules for designing a brand new API.
        There’s still some work to do on these rules, but I can now present them in something
        approaching their complete form:
            • Is there a domain-specific standard for your problem? If so, use it. Document any
            application-specific extensions (Chapter 5).
            • Does your problem fit the collection pattern? If so, adopt one of the collection
            standards. Define an application-specific vocabulary and document it (Chapter 6).
            • If neither of those is true, choose a general hypermedia format. Break down your
            application into its state transitions. Document those state transitions (Chapter 7).
            • At this point, you have your protocol semantics nailed down. The application se‐
            mantics are all that remain. Are there existing microdata items or microformats
            that cover your problem domain? If so, use them. Otherwise, define an application specific vocabulary and
            document it (Chapter 7).

        What do I mean when I say “document it?”

        This chapter is devoted to the question of documentation. If you add one more API to
        the world, how much new human-readable documentation do you really need to write?

    How Does A Client Find the Documentation?
        The server shouldn’t have to guess what an HTTP request means, and the client shouldn’t have to guess what
        a response means. It should be spelled out, or at least implied, in the message itself.

!!      HTTP’s Content-Type header is the clearest example of this. The value of this header
        tells you how to parse the entity-body. Some examples:
                Content-Type: text/html
                Content-Type: application/json
                Content-Type: application/atom+xml
                Content-Type: application/vnd.collection+json
                Content-Type: application/vnd.amundsen.maze+xml

!!!     If the media type is one that defines hypermedia controls (like an HTML document),
        then parsing a response document lets you know what HTTP requests you can make
        next. You now understand the document’s protocol semantics.

        If the media type is a domain-specific format (like Maze+XML), then parsing the document also gives you
        an understanding of a state in the problem space (like a maze cell). You now understand
        the document’s application semantics.
!!!     Once you understand both the protocol semantics and the application semantics, you’re done. You (or your
        software) can make a decision based on the available information.

        Most of the time, you won’t get both types of semantics just from the media type. Think
        about the JSON document you get from Twitter’s API. It’s served as application/
        json. Parsing that document doesn’t give you the protocol semantics or the application
        semantics. There’s some other mystery specification that’s missing

!!!!!   These “missing” specifications aren’t really missing. For hCard, the specification is at
        http://microformats.org/wiki/hcard. For Twitter, the specification is at https://dev.twit
        ter.com/docs. I’m going to call these “missing” specifications profiles. Documents like
        these are the main topic of this chapter.

    What’s a Profile?
        Here’s the formal definition of a profile, from RFC 6906:
            A profile is defined to not alter the semantics of the resource representation itself, but to
            allow clients to learn about additional semantics… associated with the resource repre‐
            sentation, in addition to those defined by the media type…

        Example:
            The human-readable documentation for the Twitter API is also a profile. You can parse
            a Twitter representation without the documentation (it’s just JSON), but you’ll know
            nothing about what it means. It’s just a JSON object. Twitter’s API documentation lets
            you understand the meaning of the JSON objects the API serves (“allow clients to learn
            about additional semantics”), without contradicting anything in RFC 4627, the JSON
            specification (“not alter the semantics of the resource representation itself ”).

    Linking to a Profile
        What’s “missing” from these representations—the HTML document that uses hCard
        and the JSON document served by Twitter’s API—is not the profile, but the connec‐
        tion between the profile and the document that uses it. The client is supposed to “just
        know” which profile(s) to apply to a given document. Well, we know how to solve that
        problem. We can link a document to its profile using hypermedia.
        There are three different ways to do this. Let’s take a look at each one in turn.

    The profile Link Relation
        RFC 6906 defines a link relation called profile. This relation is registered with the
        IANA, which means you can use profile in any hypermedia control that supports a
        link relation: the <a> tag defined by HTML; the <link> tag defined by HTML, HAL,
        and Maze+XML; a Siren or Collection+JSON links object; or the Link HTTP header
        defined by RFC 5988

        If you get an HTTP response that starts like this, you know that this is an HTML docu‐
        ment that uses the hCard microformat:
            HTTP/1.1 200 OK
            Content-Type: text/html
             <html>
                <head>
                    <link href="http://microformats.org/wiki/hcard" rel="profile">

        JSON has no protocol semantics and next to no application semantics, but if you get an
        HTTP response that starts like this, you’ll know that this document contains an extra
        layer of semantics on top of JSON’s:
            HTTP/1.1 200 OK
            Content-Type: application/json
            Link: <https://dev.twitter.com/docs>;rel="profile"


    The profile Media Type Parameter
        Depending on the media type you’re using, you may be able to link to a profile within
        the Content-Type header by adding a profile parameter to the media type. Here’s what
        the Content-Type header might look like for a Collection+JSON document:
            application/collection+json;profile="http://www.example.com/profile"

        That says: “this is a Collection+JSON document, but it has extra semantics described
        by the profile found at http://www.example.com/profile.

        The JSON spec doesn’t mention the profile parameter, so the
        following is illegal, as useful as it would be:
            Content-Type: application/json;profile="https://dev.twitter.com/docs"

        Right now, the only hypermedia types that allow for the profile parameter are Col‐
        lection+JSON, JSON-LD, HAL, and XHTML (not HTML!).

    Special-Purpose Hypermedia Controls
        In Chapter 7 I showed off HTML microdata. I said that the itemtype property was “a
        hypermedia control that tells the client where it should go to find out what the microdata means.”
            <div itemscope itemtype="http://schema.org/Person">
        I didn’t say so at the time, but this is clearly a link to a profile. It points to a document
        that provides application semantics on top of those defined by the HTML 5 specification.

    Profiles Describe Protocol Semantics
        A profile only needs to describe protocol semantics when the media type has no hy‐
        permedia controls (as with JSON), or when the controls aren’t specific enough to explain
        exactly which HTTP request the client should make (as with HAL).

 !!!!!  This is why I recommend you choose a full-featured hypermedia format like HTML or
        Siren as your representation format. You’ll still have to write a profile, but the profile
        needn’t contain a lot of detail about your API’s protocol semantics. That stuff will be
        embedded in the representations themselves.

    Profiles Describe Application Semantics
        Protocol semantics deal with HTTP requests, but application semantics refer to things
        in the real world, and computers are terrible at understanding the real world. At some
        point, we must bridge the semantic gap by writing prose that explains our application
        semantics. There’s nothing analogous to hypermedia that will save us.

    Link Relations
        a link relation is a magical string attached to a hypermedia control,
        which describes the state transition that will occur if the client triggers the control

        Example:
            <link rel="east" href="/cells/N"/>

        A hypermedia control that supports a link relation defines one slot (traditionally called
        href) for the target URL and a second slot (traditionally called rel) for the link relation.

        On their own, the names of link relations are just strings: “east,” “next,” “icon,” “current.”
        Human beings may find these names evocative, but without knowing exactly what they
        mean, there’s no way of programming a computer to understand them. That’s what
        profiles are for.

!!!!    As the API designer, you are responsible for documenting all of your
        link relations ahead of time, in a profile document or in the defini‐
        tion of a custom media type. The only exceptions are link relations that
        you took from the IANA registry (see Chapter 10). You are not ex‐
        cused from this if you think your link relations are self-explanatory,
        because they never are.
        If you use extension link relations (the ones that look like URLs), a
        human being who puts that URL into a web browser should find an
        explanation of that link relation.

    Semantic Descriptors
        There’s a schema.org microdata item called http://schema.org/Person which defines the
        property name for the same purpose:
            <span itemprop="name">Jenny Gallegos</span>
        The documentation for the Twitter API mentions a key called name, which is inserted
        into certain JSON dictionaries to indicate the name associated with a Twitter account
        (not necessarily the name of a human being):
            { "name": "Jenny Gallegos"}
        These are three different approaches to the same goal: pointing out which part of a
        representation is someone’s (or something’s) name. I’m going to call this kind of thing
        a semantic descriptor.

   !!!  As the API designer, you are responsible for documenting all of your
        semantic descriptors ahead of time, in a profile document or in the
        definition of a custom media type. You are not excused from this if
        you think your semantic descriptors are self-explanatory, because they
        never are.

    XMDP: The First Machine-Readable Profile Format
        What would a profile look like if all you had to describe were these magic strings, the
        link relations and the semantic descriptors? It would look like a microformat; that’s what
        a microformat does. It’s no surprise, then, that the first machine-readable profiles were
        descriptions of microformats. The format used in these profiles, XMDP, isn’t one I rec‐
        ommend using today, but it’s so simple that it makes for a good introduction to the concept.

        XMDP is a microformat for explaining other microformats.

    ALPS
        I’ve created a standard called ALPS that addresses the major problem I see with XMDP: it’s an HTML
        microformat designed for describing other HTML microformats. You can only use it if your representation format
        is HTML.

!!!     HTML is really, really popular. It’s the dominant representation format on the
        human web. But it’s not the dominant format for web APIs. That honor belongs to JSON,
        with XML a runner-up. HTML is a very distant third or fourth.

        One ALPS profile can explain the application semantics of all of these documents. All
        you have to do is connect the document to the profile using the profile link relation.
        But we’re just getting started. An ALPS profile can represent link relations as well as
        semantic descriptors

    Advantages of ALPS
        One ALPS document brings the application semantics of hCard to many different hy‐
        permedia formats, and gives hypermedia capabilities to ad hoc XML and JSON docu‐
        ments. All you have to do is link the representation to the ALPS document using the
        link relation profile.

        There are a few more features of ALPS that I won’t cover here, because I don’t want to
        turn this into a book about my pet standard. I will be using ALPS snippets throughout
        the rest of the book as a shorthand way of representing application semantics in a
        machine-readable form. If you’re interested in ALPS as a standard, visit the ALPS web‐
        site. As I write this, I’m working on a specification for ALPS that I plan to submit as an
        Internet-Draft.

    JSON-LD
        JSON-LD is another profile language
         JSON-LD lets you combine a machine-readable document called a context with an ordinary JSON document. This
         makes it easy to define a profile for an existing API without changing the document format, which would break
         existing clients.

        Here’s how JSON-LD would do it. Instead of serving a link to a human-readable profile
        or an ALPS profile, we’ll serve a link to a JSON-LD context. The link relation here is
        more specific than the IANA-registered relation profile. It’s an extension relation de‐
        signed specifically for linking to JSON-LD contexts:
            HTTP/1.1 200 OK
            Content-Type: application/json
            Link: <http://api.example.com/person.jsonld>;rel="http://www.w3.org/ns/json-ld↵
            #context"
            { "n": "Jenny Gallegos",
               "photo_link": "http://www.example.com/img/omjennyg" }

       Make a second HTTP GET request to http://api.example.com/person.jsonld, and you’ll
       find the context. The HTTP response might look something like this:
           HTTP/1.1 200 OK
           Content-Type: application/ld+json
           {
            "@context":
            {
            "n": "http://api.example.org/docs/Person#name",
            "photo_link":
            {
            "@id": "http://api.example.org/docs/Person#photo_link",
            "@type": "@id"
            }
            }
           }

 !!!!   Any JSON object that defines the property @context can be a JSON-LD context. This
        particular context explains the application semantics of a JSON representation, in terms
        of human-readable API documentation.

       Unlike ALPS profiles, JSON-LD contexts don’t usually explain bits of application se‐
       mantics directly. They use links to point to an explanation somewhere else.

    Embedded Documentation
        Why should a document contain human-readable and machine-readable representations of the same application
        semantics?
        The two versions of the semantics are aimed at different audiences. This redundancy
        allows human-driven clients and automated clients to use the same representations. The
        formal definition of the flip relation (as revealed in the profile) is written for client
        programmers, and the English text (embedded in the document itself) is intended for
        human consumption.

!!!!!   If you’re designing an API, and you know that all the decisions about state transitions
        will be made by human endusers, you don’t need a profile at all. Websites don’t have
        profiles. If you know that all the decisions will be made by automated clients, you don’t
        need embedded documentation at all.

        But in reality, you don’t know any of this. You probably don’t know what your users will
        do with your API, and you certainly don’t know what will happen in the future. The
        best strategy is to define a profile for use when writing automated clients, and to also
        embed natural-language documentation inside your representations, for the benefit of
        human endusers (assuming the media type supports it, of course).

    In Summary
        We can solve the semantic challenge with a combination of a well-chosen media
        type and a profile that fills in the gaps. Here’s the essential information necessary to
        solve it:

            • A link relation is a string describing the state transition that will happen if the client
            triggers a hypermedia control. Example: Maze+XML’s east relation, which lets you
            know that a certain link points to something geographically east of the current
            resource. Traditionally, the state transition is a change in application state (triggered
            with a GET request), but it can also be a change in resource state (triggered by PUT,
            POST, DELETE, or PATCH).
            • A semantic descriptor is a short string that indicates what some part of a represen‐
            tation means. Example: hCard’s fn descriptor, which is used as a CSS class to mark
            up a person’s name in HTML. Unlike “link relation,” this is a term I made up for
            this book.
            • Although link relations and semantic descriptors are meaningless on their own,
            there’s always some document nearby that contains a human-readable explanation.
            We call this document a profile
            • Profiles have traditionally taken the form of tedious “API documentation.” But if
            you chose a good hypermedia format for your representations, your profile will just
            be a list of link relations and semantic descriptors, with a prose explanation for
            each. This optimization lets you create a machine-readable profile using XMDP,
            ALPS, or JSON-LD.
            • A machine-readable profile allows a client to automatically look up the humanreadable definition of a link
            relation or semantic descriptor. Machine-readable
            profiles can be searched and remixed. The ALPS Registry contains a lot of ALPS
            profiles to work with.
            • JSON-LD contexts can take the ad hoc JSON documents served by today’s APIs,
            and describe their application and protocol semantics in a machine-readable way.
            You can use JSON-LD to retrofit a JSON API with simple hypermedia controls,
            without breaking the API’s existing clients.
            • ALPS profiles are representation agnostic. One ALPS profile can be applied to an
            HTML document, a HAL document, a Collection+JSON document, an ad hoc
            JSON or XML document, and many others.
            • Profiles are not a substitute for human-readable text embedded in hypermedia
            representations. There are two different use cases here. Profiles allow developers to
            write smart clients. Text embedded in a representation allows a human being to use
            an application through a client that faithfully renders representations.

===============================================================================================================
===============================================================================================================
Chapter 9 - The Design Procedure !!!!!!!!!!!!!!

    (this is one of the most important chapters of the book ...everything is important here :) )

    It’s taken quite a while, but I’m now in a position to address the basic concern that may
    have led you to buy this book. You need to design an API: what should it look like? In
    this chapter, I’ll lay out a procedure that begins with business requirements and ends
    with some software and some human-readable documentation.

    Two-Step Design Procedure
!!!     In its simplest form, the procedure has two steps:
        1. Choose a media type to use in your representations. This puts constraints on your
        protocol semantics (the behavior of your API under the HTTP protocol) and your
        application semantics (the real-world things your representations can refer to).
        2. Write a profile that covers everything else.

!!!!!   This won’t necessarily give you a good API. In fact, this version of the procedure de‐
        scribes every API ever designed. If you wanted a really generic design that’s hard to
        learn, you’d blaze through step 1 by choosing application/json as your representation
        format. Since JSON puts no constraints on your protocol or application semantics, you’d
        spend most of your time in step 2, defining a fiat standard and describing it with human readable API documentation.

        That’s what most APIs do today, and that’s what I’m trying to stop. A big chunk of the
        work that goes into creating a fiat standard is unnecessary, and client code based on a
        fiat standard can’t be reused. But doing anything else requires some preparatory thought
        and a willingness to reuse other people’s work when possible.

!!!!!!!! (all this )
    Seven-Step Design Procedure
        1. List all the pieces of information a client might want to get out of your API or put
        into your API. These will become your semantic descriptors.
        Semantic descriptors tend to form hierarchies. A descriptor that refers to a real world object like a person will
        usually contain a number of more detailed, more abstract descriptors like givenName. Group your descriptors
        together in ways that make intuitive sense.

        2. Draw a state diagram for your API. Each box on the diagram represents one kind
        of representation—a document that groups together some of your semantic de‐
        scriptors. Use arrows to connect representations in ways you think your clients will
        find natural. The arrows are your state transitions, triggered by HTTP requests.
        You don’t need to assign specific HTTP methods to your state transitions yet, but
        you should keep track of whether each state transition is safe, unsafe but idempo‐
        tent, or unsafe and nonidempotent.
        At this point, you may discover that something you put down as a semantic de‐
        scriptor (the customer of a business) makes more sense as a link relation (a busi
        ness links to a person or another business using the link relation customer). Iterate
        steps 1 and 2 until you’re satisfied with your semantic descriptors and link relations

        Now you understand your API’s protocol semantics (which HTTP requests a client will
        be making) and its application semantics (which bits of data will be sent back and forth).
        You’ve come up with a list of magic strings (semantic descriptors and link relations)
        that make your API unique, and you know roughly how those magic strings will be
        incorporated into HTTP requests and responses. You can then move on to the following steps:

        3. Try to reconcile your magic strings with strings from existing profiles. I list some
        places to look in “The Semantic Zoo” on page 230. Think about IANA-registered link
        relations, semantic descriptors from schema.org or alps.io, names from domain specific media types, and so on.
        This may change your protocol semantics! In particular, unsafe link relations may
        switch back and forth between being idempotent and not being idempotent.
        Iterate steps 1 through 3 until you’re satisfied with your names and with the layout
        of your state diagram.

        4. You’re now ready to choose a media type (or define a new one). The media type
        must be compatible with your protocol semantics and your application semantics.
        If you’re lucky, you may find a domain-specific media type that already covers some
        of your application semantics. If you define your own media type, you can make it
        do exactly what you need.
        If you choose a domain-specific media type, you may need to go back to step 3, and
        reconcile your names for semantic descriptors and link relations with the names
        defined by that media type.

        5. Write a profile that documents your application semantics. The profile should ex‐
        plain all of your magic strings, other than IANA-registered link relations and strings
        explained by the media type.
        I recommend you write the profile as an ALPS document, but a JSON-LD context
        or a normal web page will also work. The more semantics you borrowed from other
        people in step 4, the less work you’ll have to do here.
        If you defined your own media type, you may be able to skip this step, depending
        on how much of this information you put in the media type specification

        6. Now it’s time to write some code. Develop an HTTP server that implements the
        state diagram from step 3. A client that sends a certain HTTP request should trigger
        the appropriate state transition and get a certain representation in response.
        Each representation will use the media type you chose in step 4, and link to the
        profile you defined in step 5. Its data payload will convey values for the semantic
        descriptors you defined in step 1. It will include hypermedia controls to show the
        client how to trigger the further state transitions you defined in state 2.

        7. Publish your billboard URL. If you’ve done the first five steps correctly, this is the
        only information your users will need to know to get started with your API. You
        can write alternate human-readable profiles (API documentation), tutorials, and
        example clients to help your users get started, but that’s not part of the design.

        Now let’s take a closer look at each step, using the maze game from Chapter 7 as an example.


    Step 1: List the Semantic Descriptors
        Here are all the pieces of data in play in the maze game:
        • A maze
        • A maze cell
        • A switch
        • The position of a switch (“up” or “down”)
        • The title of a maze cell
        • A doorway connecting one maze cell to another
        • An exit from a maze
        • A list of mazes

        When I try to put them into a hierarchy, here’s what I come up with:
        • A list of mazes
             — A maze
                — A maze cell
                    — A title
                    — A doorway connecting one maze cell to another
                    — An exit from the current maze
                    — A switch
                         — A position (“up” or “down”)


    Step 2: Draw a State Diagram
        Figure 9-2 shows my first try at a state diagram for the maze game.  (see book)

        Clearly, there should be a link from the list of mazes to an individual maze, and from a maze to
        the starting cell in the maze. For now, I’ll call the link relations for these links maze and start.

        Looking at the diagram in Figure 9-2, it should be clear by now that “a doorway connecting one
        maze cell to another” isn’t a standalone piece of data. It’s a link: a relationship between
        two cells. Similarly, “an exit from the current maze” is not a piece of data. It’s a link
        between a maze cell and something else not on the diagram. This means north and exit
        shouldn’t be semantic descriptors: they should be link relations.

        Now the state diagram for the maze game resembles an actual maze—compare it to
        Figure 5-3. It’s not a very interesting maze. All the fun of solving a maze—of going north,
        then east, then east again—has been abstracted into a single arrow that connects one
        cell representation to another. But the important thing is that every HTTP request a
        client makes can be represented as a journey along one of those arrows, from one rep‐
        resentation to another. You can’t say that about Figure 9-2.

        As I said in Chapter 3, anything important enough to be
        the topic of a client-server conversation should be a resource with its own URL. Making
        a switch a standalone resource will eliminate any ambiguity about whether an HTTP
        request is addressing a maze cell or a switch.
        A switch is part of a maze cell, but
        it supports a state transition (flip) that doesn’t apply to the cell as a whole. That’s why
        a switch makes sense as a standalone resource

        Locating the home page
!!!     Your state diagram should include one arrow that comes in out of nowhere. This rep‐
        resents the client’s initial GET request to your billboard URL. Every other arrow must
        originate in one of the representations, and every representation must be accessible from
        the starting representation, via a state transition.
        If there’s an obvious top level to the hierarchy you set up in step 1, then you have an
        obvious candidate for your top-level representation. In this case, the top-level repre‐
        sentation is the list of mazes.


    Step 3: Reconcile Names
        Technically, you can skip this step. Your API will have the same design no matter what
        names you give to your magic strings. But names matter quite a bit to humans. Although
        computers will be your API’s consumers, they’ll be working on behalf of human beings,
        who need to understand what the magic strings mean. That’s how we bridge the semantic gap.

        Thousands of people have spent hundreds of person-years coming up with profiles for
        all kinds of problem domains. (Again, see “The Semantic Zoo” on page 230.) There are
        profiles conveying the application semantics necessary to represent people, groups of
        people, companies, events, products, payment methods, geographical locations, land‐
        marks, books, TV shows, job listings, medical conditions, blog posts, recipes, and more.
        Not to mention the online interactions of human beings with all of these—joining
        groups, leaving groups, RSVPing to events, writing blog posts, “liking” videos, and so
        on. The most generic, most reusable bits of these profiles are promoted to the hall of
        fame: the list of IANA-registered link relations.

        I suggest you spend some time looking through these profiles for names you can reuse.
        Reusing existing names when possible will reduce the chance that a human being will
        misunderstand one of your magic strings. It reduces the amount of documentation you
        have to write, since you’ll be able to reuse the profiles that define those names. It increases
        the chances that a client developer will be able to reuse an existing library. And it reduces
        the chances that you’ll need to change a name later

        It’s true that most existing profiles are tied to a specific media type, and I think it’s a
        terrible idea to choose a media type just so you can use a profile. This is why I came up
        with ALPS, and why I made such a big deal about it in Chapter 8. ALPS liberates profiles
        from their media types.

        A Siren document can’t use schema.org’s microdata profile for describing books. But it
        can use an ALPS profile that’s based on schema.org’s profile. That’s a lot less work than
        coming up with a brand new Siren profile, and it increases the chances that your users
        will already be familiar with a given set of application semantics

        Almost any consumer-facing API can reuse some semantics in this way. Most notably,
        you shouldn’t need to come up with your own terms for describing personal information
        about human beings. Between hCard, schema.org’s Person, and FOAF, that domain is
        pretty well covered.

        If you think my vision of reusable semantics across APIs is ridiculously unrealistic, or
        that it’s too much work to scavenge for reusable semantic descriptors, you’re free to
        make up your own names for everything. As I said, on a technical level, the names don’t
        matter at all. But I do have two rock-bottom pieces of advice that you should always
        follow:

            First, don’t autogenerate the names of your semantic descriptors from the fields in your
            database schema or object model. That will give your clients a software dependency on
            your server-side code. When you change that code, you’ll break all your clients until
            you introduce a compatibility layer that presents the old names through your API.

            Second, don’t come up with link relations that duplicate the functionality of IANA registered link relations.
            Those link relations were put in the registry specifically because
            they’re not tied to a media type or an application domain. These are the most generic
            bits of application semantics around, and they’re all listed in one place for easy reuse.

        Here are some specific examples:
            • Any time you’ve got a relationship between a list of things and an individual thing
            in the list, consider using the IANA-registered link relations collection and
            item, instead of (or in addition to) something more specific.
            • There are two main ways of paginating resource state across multiple representa‐
            tions. The obvious way, which you should be familiar with from websites, uses the
            link relations first, last, next and previous (or prev). The archive-based tech‐
            nique described in RFC 5005 uses the link relations current, next-archive, and
            prev-archive. Unless you’ve come up with a third pagination technique, there’s no
            reason to make up new names for these relationships.

        What if instead of flip, the link relation was called edit? Instead of changing the
        position of a switch relative to its current position, the client would decide what position
        it wanted—either up or down—and send that information along when it triggered the
        edit transition. The API’s state diagram would look like Figure 9-6.

        Replacing flip with edit would have two advantages. Instead of learning a brand new
        link relation, a client can reuse its existing knowledge of an IANA-registered relation
        (edit).

    Step 4: Choose a Media Type
        This will probably be one of the hypermedia types I mention in Chapter 6, Chapter 7, or Chapter 10.
        You’re also free to design a new domain-specific media type, although you shouldn’t need to.

        Although there’s not one media type that’s always the best choice, a few common patterns
        emerge at this point. If your state diagram resembles Figure 9-7, your protocol semantics
        implement the collection pattern. You should consider Collection+JSON, AtomPub, or OData (see Chapter 10).

        If your state diagram looks more like the mess in Figure 9-8, you probably want a generic
        hypermedia language: HTML, HAL, or Siren.

!!!!    If you’re thinking of using JSON at this point, I must remind you that JSON is not a
        hypermedia format. The JSON standard defines concepts like numbers, lists, strings,
        and objects. It does not define the concepts of links or link relations, so it has no hy‐
        permedia capabilities. You want something more specific: maybe HAL, Siren, Collection+JSON, or Hydra.

        If your API is read-only—that is, your state diagram doesn’t include any unsafe transi‐
        tions—you’ve got a lot of good options. I suggest HTML, HAL, or JSON-LD.

        Collection+JSON supports three specific unsafe transitions: adding a new item to a
        collection, editing an item, and deleting an item. That’s it. You can’t use any unsafe
        transitions other than the three defined by the media type.

    Step 5: Write a Profile
        When your server sends a representation, it will include the Content-Type header,
        which tells the client how to parse the representation. You’ll also include a link to one
        or more profiles, which will explain the representation’s application semantics.

        Your profile can be an ALPS document, a JSON-LD context, or a web page that uses the
        XMDP microformat. If none of these choices work for you, you can give up on the idea
        of a machine-readable profile and write a human-readable profile instead

        A human-readable profile looks like traditional API documentation. It’s a web page
        laying out the meaning of all the link relations and semantic descriptors. You can still
        reuse link relations and descriptors from alps.io and other profiles—just copy and paste
        the text, and be sure to link back to the original profile.

    Step 6: Implementation
        You’re going to spend most of your time in this step, and I don’t have much advice,
        because it depends on the framework and programming language you’re using.
        have a state diagram and a profile that you’re happy with, it won’t necessarily be an easy
        job, but it should at least be straightforward.

    Step 7: Publication
        This is more complicated than just putting some API documentation up on your web‐
        site, but it’s not much more complicated. I’m just laying it all out so you don’t accidentally
        skip a step.

        Publish your billboard URL
            Back in step 2, I said you should have a box on your state diagram that had an arrow
            coming into it out of nowhere. This box represents your home page: a hypermedia
            gateway to all your other resources. Everyone who wants to write a client for your API
            must know the URL of your home page. The rest is negotiable.

        Publish your profile
            Your profile document goes on your website, along with the rest of the information
            about the API. If you’ve written an ALPS profile, I’d appreciate it if you’d also register
            it with the ALPS Registry at alps.io. This will help other people find and reuse the link
            relations and semantic descriptors you defined.

        Register new media types
            You probably won’t need to design a new media type, so I won’t take up space here
            explaining what to do once you’re done designing. (Instead, I’ll cover it later, in “If You
            Design a Media Type” on page 183).

        Register new link relations
            RFC 5988 doesn’t say exactly how a link relation might be registered, but I’d say there
            are four ways:
                • It might be found in the IANA registry of link relations. Any API provider is allowed
                to use IANA-registered link relations in its representations without defining them.
                A useful example is the replies relation defined in RFC 4685.
                Section 6.2 of RFC 5988 describes the IANA registration process. Getting a link
                relation into this registry requires writing an RFC (or equivalent document), and
                only relations that are generally useful are accepted, so relatively few developers
                will take this route.

                • If a media type defines a link relation that conflicts with a relation registered with
                the IANA, the media type’s definition takes precedence. Don’t do this intentionally!

        Publish the rest of the documentation
            There’s plenty more documentation to be published, but it’s all human-readable docu‐
            mentation specific to your API: summaries, examples, sample code, instructions on
            setting up authorization, marketing copy explaining how your API differs from others.

!!!!        If an API is described only in prose, then changing the prose means rewriting all the clients. That’s
            a big problem with current APIs, and it’s a problem I’m trying to mitigate with this book

        Well-known URIs
            Here’s a thought: what if you didn’t need to advertise your billboard URL? What if your
            clients just knew how to find the entry point to your API? That’s the promise of the
            IANA’s “Well-Known URIs,” established in 2010 by RFC 5785.

            If a server presents representations in CoRE Link Format (covered in Chapter 13), there’s
            no need to wonder what the billboard URL is. It should always be /.well-known/core.
            That (relative) URL is registered with the IANA. Instead of learning a different billboard
            URL for every server, a CoRE client can always send a GET request to /.well-known/core
            and get a list of hypermedia links to other resources hosted on that server. A server
            that serves a web host metadata document (Chapter 12) should always serve that docu‐
            ment from /.well-known/host-meta or /well-known/host-meta.json.

            Thanks to the Well-Known URI Registry, it’s theoretically possible for a client to explore and learn a
            new API, given only the hostname.

            The catch is that well-known URIs are generally associated with specific media types.
            As I write this, if you’re not using CoRE Link Format or web host metadata, you can’t
            publish your API at a well-known URI. Those are the only two formats in the WellKnown URI Registry that are
            useful for APIs.

!!!!
    Example: You Type It, We Post It
        (very nice example in which the author goes through all the steps described in this chapter)


!!!!!!                          (all these advice are good)
    Some Design Advice
        Hopefully by this point you have a good idea of how I go through my design process.
        Now I’d like to bring up some practical lessons I’ve learned from developing and ap‐
        plying this process.

        Resources Are Implementation Details
            Most procedures for designing RESTful web APIs focus on resource design. But there
            are no resources here. The boxes in the state diagrams aren’t resources, they’re repre‐
            sentations of resources—the actual documents sent back and forth between client and
            server.

            This was not an oversight. Resources are primary to HTTP, and they’re very important
            to API implementations, but I’ve come to realize that they’re not very important to REST,
            per se. My design process focuses on state transitions and semantic descriptors. Once
            you have those nailed down, you have your resources.

            Think of the HTTP back-and-forth between client and server. A resource receives a
            GET request and serves a representation with a certain media type. The representation
            contains hypermedia controls, which describe possible state transitions. A client acti‐
            vates a state transition by sending an HTTP request to another resource, which imple‐
            ments the state change and sends another representation. The client never directly in‐
            teracts with a resource.

            Focusing on resources first won’t give you a bad design, but it does tend to express a
            design in terms of the server-side implementation, rather than in terms of the client’s
            experience. It’s also easy to use good resource design (backed up by copious humanreadable documentation)
            as an excuse to avoid thinking about hypermedia.

        Don’t Fall into the Collection Trap
!!!!        Don’t use your database schema as the basis for your API design.
            Draw a state diagram instead.

            Thanks to modern tools, this strategy will very quickly get you an API that works, but
            it has two big problems. The first stems from the fact that your users don’t care about
            your database schema. They care about your application semantics, and the two are only
            vaguely related. You wouldn’t set up a website that was just a raw interface into your
            database. You should put the same thought into designing an API as you would a website.

            On the other hand, you do care about your database schema—so much so that you
            reserve the right to change the schema as your requirements change. That’s the second
            problem. When you publish an API based on a database schema, changes to the schema
            become basically impossible. You’ve given a software dependency on your database
            schema to thousands of people you’ve never heard of. These people are your clients and
            supporting them is your responsibility. Changes to the schema, changes that your web‐
            site users won’t even notice, will cause big problems for your API users.

            Thinking about state transitions forces you to consider your
            application, not the database that contains all the resource state.

            But draw the state diagram first. Don’t confuse the protocol semantics defined by your application
            with the interface defined by your database.

        Don’t Start with the Representation Format
            It’s fine to use a general format like HTML for doodling, but I recommend you hold off on
            a decision until you’ve gotten, however tentatively, to step 4. That’s because represen‐
            tation formats aren’t just passive containers for data. They introduce assumptions about
            protocol and application semantics into every API that uses them. These assumptions
            may conflict with your business requirements.

            To take a less silly example, suppose you start off by deciding to use Collection+JSON
            (or AtomPub, or OData) for your API. That means you’ve chosen a set of semantics that
            implement the collection pattern. You’re stating up front that your API’s state diagram
            looks something like Figure 9-7.
            How can you say that in advance? If it turns out your protocol semantics fit the collection
            pattern (and they often will), then the collection-pattern standards are just what you
            need. But you can’t go on a gut feeling; you need to actually draw the state diagram.

            Of course, if the use of a particular representation format is one of your business re‐
            quirements, you might as well make that decision first, and design your API around the
            mandatory representation format.

        URL Design Doesn’t Matter
            Some API design guides, including the original RESTful Web Services, spend a lot of
            time talking about the URLs you should assign to your resources. Each URL you serve
            should clearly identify the resource in such a way that a human being looking at the
            URL can figure out what’s on the other end.

            If you publish a resource that’s a collection of user accounts, it should be called some‐
            thing like /users/. Subordinate resources should be published beneath their parents. So
            the resource representing Alice’s account should be given a URL like /users/alice.
            Well, sort of.

            Technically speaking, none of this matters. A URL is just the address of a resource, which
            a client can use to get a representation. The URL doesn’t technically say anything about
            the resource or its representation

            The Architecture of the World Wide Web, Volume One puts it this way:
                "It is tempting to guess the nature of a resource by inspection of a URI that identifies it.
                However, the Web is designed so that agents communicate resource information state
                through representations, not identifiers. In general, one cannot determine the type of a
                resource representation by inspecting a URI for that resource."

            This means it’s perfectly legal for the collection of user accounts to have the
            URL /000000000000a, and for that collection to link to Alice’s user account using the
            URL /prime-numbers?how_many=200. The important thing is that the representation
            of a collection of users makes it clear that it’s representing a collection of users, and that
            the representation of Alice’s user account contains information about the state of that resource

            When you look at a URL and try to make sense of the underlying resource, you’re trying
            to figure out the resource’s application-level semantics. That’s fine. The advice on URL
            design given in other books and tutorials is good advice. But I won’t rehash that advice
            in this book, because I don’t want your APIs relying on URLs to convey their application level semantics.
            We have more reliable ways of describing that stuff: media type definitions and machine-readable profiles

            Again, there’s nothing wrong with nice-looking URLs. Nice-looking URLs are great!
            But they’re cosmetic. They look nice. They don’t do anything. Your API clients should
            continue to work even if all of the nice-looking URLs were suddenly replaced with
            randomly generated URLs.

        Standard Names Are Probably Better Than Your Names
            Let’s say that your application semantics include “a person’s first name.” You’d write that
            down in step 1, you’d try to fit it into a hierarchy, and you’d give it a temporary name
            based on the corresponding field in your database schema or your data model. Some‐
            thing like first_name, firstname, first-name, fn, first name, first, fname, or giv
            en_name. That’s fine for step 1. But when you get to step 3 you need to look around,
            notice that there are lots of existing profiles for describing peoples’ first names, and
            adopt one of them

            You may be attached to the names you chose in step 1. But you’re not doing this API
            for yourself. You’re doing this for your users.
            Over their careers, users will consume lots of different APIs, and they’ll benefit from not having
            to learn 20 slightly different names for the same thing.

            But which profile to choose? The hCard standard says that the semantic descriptor for
            a person’s given name is given-name. The xCard standard says it’s given. The FOAF
            standard says it’s givenName, but that firstName may be used when interpreting legacy
            data. The schema.org Person item only allows for givenName. These are well-defined,
            respected standards that conflict with each other.
            That’s annoying, but there’s no reason to make up more names and make the situation
            worse. Just pick a profile—whichever one has the best overall fit with your API’s appli‐
            cation semantics—and use the names it defines.

        If You Design a Media Type
            The advantage of a new media type is the complete control it gives you over how clients
            process your documents. You don’t have to base your API on XML, JSON, or HTML.
            You can declare a brand new binary file format and give byte-by-byte instructions for
            how to handle it. You don’t have to scrounge around for profiles that reflect your ap‐
            plication semantics. Whatever you say, goes

            If you expect people outside your organization to be passing around documents that
            use your media type, you’ll also need to tell the world how to process those documents.
            This means registering your media type with the IANA.

        When Your API Changes
            One of today’s most hotly debated topics in the API community is versioning. It’s an
            enormous problem. Most companies that put out an API never change that API after
            its initial release. They can’t do it.

            To be blunt, they can’t do it because they ignored the hypermedia constraint. Most APIs
            put their protocol and application semantics into human-readable documentation. The
            users of those APIs then write a bunch of client software based on that documentation.
            Now the API providers are stuck. They can change the documentation, but doing so
            won’t automatically change the behavior of all those clients. They’ve given their users
            veto power over any change in their design.

            But a change to a hypermedia document does change the behavior of every client that
            receives it. That’s why a website can undergo a total redesign without breaking everyone’s
            web browsers. A website is entirely contained in the representations it serves. There’s
            nothing extra hidden away in human-readable documentation.

            Moving your API’s semantics out of human-readable documentation and into hyper‐
            media documents makes your API more resilient in the face of change. Choose a good
            hypermedia format, and you can add new resources and state transitions to your API
            without affecting existing clients. You’ll also have quite a bit of room to change your
            protocol semantics.

            If you change a resource and your clients can’t automatically adapt to the change, you’ll
            need to spend some period of time effectively publishing two different resources—the
            old one and the new one—with different application or protocol semantics. There are
            three common strategies for doing this.

                1. Partitioning the URL space
                    In the most common versioning technique, the entire API is split into two disjoint APIs.
                    Sometimes the two APIs have different billboard URLs, like http://api-v1.example.
                    com/ and http://api-v2.example.com/.

                2. Versioning the media type
                    If you defined a domain-specific media type for your application, you can give it a
                    version parameter. Clients can then use content negotiation (see Chapter 10) to ask for
                    one version or the other:
                    Accept: application/vnd.myapi.document?version=2

                    I don’t think you should define a domain-specific media type in the first place, but even
                    if you do, this is a bad idea. Your media type is not your API. Here’s a thought experiment:
                    could another company use your media type in their own, unrelated API?

                3. Versioning the profile
                    I recommended that you base your API around a standardized media type, and obvi‐
                    ously you can’t go in and declare a new version of someone else’s media type. But I also
                    recommended that you define your application semantics in a machine-readable profile,
                    and you can declare a new version of a profile.

            API versioning gets a lot of attention because the problem is a lot worse for an API that
            ignores the hypermedia constraint. But it’s just one example of the general problem
            addressed by hypermedia. How does the client know which resource has the represen‐
            tation it wants? Once the client gets a representation, how is it supposed to know what
            the representation means? The techniques I gave earlier are the techniques a server uses
            in general when giving the client a choice between representations.
            A server can give out links to two different URLs, and the client can choose which link
            to follow based on an understanding of the application semantics. It’s the same whether
            the two URLs point to completely different resources, or to the v1 and v2 versions of a
            single underlying resource.

            Have an end-of-life plan
                When you must change a resource’s semantics in a way that
                breaks backward compatibility, you create a second version of that resource for use by
                new clients. The second version can be identified by a different URL, a different media
                type, or whatever. Unmodified clients can still use the old version.

                Eventually you’d like to get rid of the old version. After all, if you liked the old func‐
                tionality, you wouldn’t have changed it. Again, there’s no technical solution here. The
                issue is your relationship with your users. You need to set expectations for when one
                version of your API will be deprecated, and how long a client can expect to keep using
                a deprecated API.

                When you publish your API, include some level of assurance on how long it will be
                valid. You can give a lifetime assurance (“We’ll continue to support this API for 5 years.”)
                or you can give a notification assurance (“We’ll give you a one-year warning before we
                stop supporting this API.”) Also set up a communication channel specifically for com‐
                munication about this: a web page or a mailing list.

                How quickly you can move through these steps depends on the size of your user base
                and the average speed at which your community can change. Changing a banking API
                will take a long time; changing a microblogging API will go faster

        Don’t Keep All the Hypermedia in One Place
            A hypermedia-based API has a limited ability to express server-side changes without
            breaking clients. But you don’t get this ability automatically; you have to work for it. It’s
            quite possible to write a machine-readable “service description document” in HTML.
            On the Web, we’d call that a site map

            A client for a hypermedia API can’t expect to know about all the possible state transitions
            ahead of time. It needs to be designed like a maze solver, capable of making a decision
            based on the possible next steps presented by the server at runtime. That’s why I rec‐
            ommend splitting up your hypermedia controls so that each representation, as it’s
            served, contains the controls that are relevant to the current application and resource
            state. This will force client developers to reckon with hypermedia, instead of pretending
            they can ignore it.

            I bring this up because there are push-button tools that will inspect your server imple‐
            mentation and generate an API for you, an API described by a hypermedia-based service
            document. There’s nothing technically wrong with this—hypermedia in a service docu‐
            ment is still hypermedia—but it will encourage your users to put their faith in the idea
            that the service document won’t change. Everything will seem fine at first, but as your
            API evolves, you’ll start running into problems. You will have checked a feature box
            labeled “hypermedia,” but you won’t actually get the benefits that come from adopting
            hypermedia.

            Any hypermedia format might be used to write a service document, but there are three
            in particular that especially lend themselves to this antipattern. They are OData and
            WADL (which I’ll cover in Chapter 10) and Hydra (which I’ll cover in Chapter 12). As
            I cover them, I’ll remind you of this forewarning.

!!!!!
    Adding Hypermedia to an Existing API
        You should be able to get your API up to the level of quality I advocate in this book,
        without breaking your existing clients. Here’s a modified version of the seven-step pro‐
        cess I laid out earlier, for fixing up a JSON-based API:

            1. Document all your existing representations. Each one will contain a number of
            semantic descriptors. You can’t change these, but you should be able to add new
            ones.

            2. Draw a state diagram for your API. The boxes on the diagram are your existing
            representations. You probably won’t have any state transitions, because most exist‐
            ing APIs don’t have any hypermedia links. Now’s the time to add some. Use arrows
            to connect representations in ways that make sense. The names of the arrows are
            your link relations. At this point it may turn out that some of your semantic descriptors are actually
            link relations:
            { "homepage": "http://example.com" }
            You can convert them to link relations at this point, but be sure not to rename them
            when you get to the next step.

            3. You can’t change the name of anything you wrote down in step 1, because that would
            break your existing clients. But you can go through the link relations you created
            in step 2, and make sure their names come from the IANA and other well-known
            sources whenever possible.

            4. You can’t change your media type, because that would break your clients. It’ll have
            to stay application/json (or whatever it is now).

            5. Since you can’t change the media type, all your application semantics and protocol
            semantics must be defined somewhere else. You’ve got two choices: an ALPS profile
            or a JSON-LD context.
            If you wrote down any unsafe link relations in step 2, your best choice is JSON-LD
            with Hydra (see Chapter 12). You should be able to take your human-readable
            descriptions of API calls and convert them into machine-readable Hydra opera‐
            tions.

            6. You’ve already got most of the code written. You’ll just need to extend each repre‐
            sentation by serving appropriate links.

            7. Your billboard URL will be the same as before. If you didn’t have one before, because
            your API was a group of discrete API calls, you can create a new resource to act as
            your home page, and know that only hypermedia-aware clients will access it.

===============================================================================================================
===============================================================================================================
Chapter  10 - The Hypermedia Zoo

    There are a lot of hypermedia document formats in active use. Some are designed for
    very specialized purposes—the people who use them may not even think of them as
    hypermedia formats. Other hypermedia formats are in such common usage that people
    don’t really think about them at all. In this chapter, I’ll take you on an educational tour
    of a “zoo” containing the most popular and most interesting hypermedia formats.

    I won’t be going into a lot of technical detail. Any one of these formats probably isn’t
    the one you want to use, and I’ve covered many of them earlier in the book. Many of
    the formats are still under active development, and their details might change. If you’re
    interested in one of the zoo’s specimens, the next step is to read its formal specification.

    The hypermedia zoo is so full that you probably don’t need to define a brand new media type for your API. You
    should be able to pick an existing media type and write a profile for it.

    I’ve organized the hypermedia zoo along the lines of my introduction to hypermedia.
    There’s a section for domain-specific formats (a la Chapter 5), a section for formats
    whose primary purpose is to implement the collection pattern (a la Chapter 6), and a
    section for general hypermedia formats (a la Chapter 7).

    Domain-Specific Formats
        These media types are designed to represent problems in one particular domain. Each
        defines some very specific application semantics, and although you might be able to use
        them to convey different semantics, it’s probably a bad idea.

        Examples:
            Maze+XML
            OpenSearch
            Problem Detail Documents
            SVG
                SVG makes a good alternative to HTML for building mobile applications. SVG can also
                be combined with HTML 5: just stick an <svg> tag into HTML markup to get an inline
                SVG image.

            VoiceXML
                Each <choice> tag is a hypermedia link. The browser waits for you to activate a link by
                saying something. It uses speech recognition to figure out which link you’re activating.
                There’s a validation step: if you say nothing, or you say something that doesn’t map onto
                one of the links, the browser reads you an error message (either <noinput> or <no
                match>) and waits for input again

    Collection Pattern Formats
        The three standards in this section have similar application and protocol semantics,
        because they all implement the collection pattern I laid out in Chapter 6. In the collection
        pattern, certain resources are designated “item” resources. An item usually responds to
        GET, PUT, and DELETE, and its representation focuses on representing structured bits
        of data. Other resources are designated “collection” resources. A collection usually re‐
        sponds to GET and POST-to-append, and its representation focuses on linking to item
        resources

        Collection+JSON
            It’s a formalized, hypermedia-aware version of the API developers
            tend to design their first time through the process.

        The Atom Publishing Protocol
            The original API standard, AtomPub pioneered the collection pattern and the RESTful
            approach to APIs in general. As an XML-based standard in a field now dominated by
            JSON representations, AtomPub now looks somewhat old-fashioned, but it inspired
            several other standards and link relations that can be used with other hypermedia formats.

        OData
            OData also defines a set of implicit protocol semantics for filtering and sorting a col‐
            lection, using a query language similar to SQL. If you know you have the URL to an
            OData collection, you can manipulate that URL in a wide variety of ways
            Sending GET to the resulting URLs will yield representations that filter and paginate the collection in
            different ways.

            A client doesn’t need a hypermedia form to know it’s OK to send
            GET requests to certain URLs. The OData format itself puts additional constraints on
            the server that guarantee that certain URLs will work.

            You can search for posts that include “second” in their Content and were PostedBy a
            resource whose Username property is “alice”:
            /Posts$filter=substringof('second', Content)+ and +PostedBy/Username eq 'alice')

    Pure Hypermedia Formats
        These media types have very generic application semantics, or else they have no appli‐
        cation semantics at all. They focus on representing the protocol semantics of HTTP

!!!!!
        HTML
            The original hypermedia format, and a highly underrated choice for an API. HTML can
            make direct use of microformats and microdata, instead of using an approximation such
            as an ALPS profile. HTML’s <script> tag lets you embed executable code to be run on
            the client, a feature of RESTful architectures (“code on demand”; see Appendix C) not
            supported by any other hypermedia format. And HTML documents can be graphically
            displayed to human beings—invaluable for APIs designed to be consumed by an Ajax
            or mobile client, and useful when debugging any kind of API.

            HTML comes in three flavors. HTML 4 has been the stable standard since 1997. HTML
            5, its replacement, is still under development. There’s also XHTML, an HTML-like
            format that happens to be valid XML.
            As far as this book is concerned, the only important differences between these three
            standards are HTML 5’s new rules for client-side input validation, and the fact that
            HTML 5 will eventually support microdata.

        HAL
            HAL relies on custom link relations (and their human-readable explanations in profiles)
            to do the heavy lifting.

        Siren
            A Siren document describes an “entity,” a JSON object that has approximately the same
            semantics as HTML’s <div> tag. An entity may have a “class” and a list of “properties.”
            It may contain a list of “links,” which work like HTML <a> tags (with a rel and an
            href). It may also contain a list of actions, which work like HTML <form> tags (with
            a name, an href, a method, and a number of fields).
            An entity may also have some number of subentities, similar to how one <div> tag may
            contain another. You can implement the collection pattern this way.

        The Link Header
            The Link header is not a document format, but I’m putting it in the zoo because it lets
            you add simple GET links to representations that lack hypermedia controls, like binary
            images or JSON documents. The header’s rel parameter is a slot for the link relation:
                Link: <http://www.example.com/story/part2>;rel="next"

            As far as I’m concerned, the most important use of the Link header is to connect a JSON
            document with a profile. JSON is incredibly popular despite having no hypermedia
            controls, and the application/json media type doesn’t support the profile parameter,
            so Link is the only reliable way to point to the profile that explains what a JSON docu‐
            ment means.
                Content-Type: application/json
                Link: <http://www.example.com/profiles/hydraulics>;rel="profile"

        URL Lists
            A text/uri-list document is just a list of URLs:
                http://example.org/
                https://www.example.com/
                ...
            This is probably the most basic hypermedia type ever devised. It doesn’t support link
            relations, so there’s no way to express the relationship between these URLs and the
            resource that served the list. There are no explicit hypermedia controls, so the client has
            no way of knowing what kind of requests it’s allowed to send to these URLs. The best
            you can do is send a GET request to each and see what kind of representations you get.

        JSON Home Documents
            JSON Home Documents are a more sophisticated version of URL lists. The format is
            intended for use as the “home page” of an API, listing all the resources provided and
            their behavior under the HTTP protocol.

            By combining a JSON Home Document (which describes an API’s protocol semantics)
            with an ALPS document (which describes its application semantics), you can take an
            existing API—even one that doesn’t use hypermedia—and move most of its humanreadable documentation into a
            structured, machine-readable format.

        WADL
            WADL was the first hypermedia format to support a complete set of protocol semantics.
            A WADL <request> tag (analogous to an HTML form) can describe an HTTP request
            that uses any method, provides values for any specified HTTP request headers, and
            includes an entity-body of any media type.
            WADL can describe the protocol semantics
            of any web API, even one that’s poorly designed and violates the HTTP standard.

            WADL is not in widespread use, but there are some Java JAX-RS implementations that
            generate WADL descriptions of APIs. Therein lies the problem. An automatically gen‐
            erated description of an API is likely to be tightly coupled to the server-side implemen‐
            tation. What’s more, an API that uses WADL typically serves one enormous WADL
            document describing the protocol semantics of the entire API.

            This is a service description document, and as I mentioned in Chapter 9 , it encourages
            users to create automatically generated clients, based on the assumption that they’ve
            obtained a complete and unchanging overview of the API’s semantics.
            But APIs change. When that happens, the WADL description of the API will also change,
            but the automatically generated clients will not. The clients will break.

        XLink
            XLink is a plug-in standard that lets you add hypermedia links to any XML document.
            Unlike HTML and Maze+XML, XLink doesn’t define special XML tags that represent
            hypermedia links. XLink defines a family of attributes that can be applied to any XML
            tag to turn that tag into a link.

        XForms
            XForms does for hypermedia forms what XLink does for links. It’s a plug-in standard
            that adds HTML-like forms to any XML document. Unlike XLink, though, it does define
            its own tags.

!!!!!
    The Semantic Zoo
        Rather than show you a lot of individual profiles in the semantic zoo, I’ll focus mainly
        on the registries that house the profiles.

        The IANA Registry of Link Relations
            I’ve talked about the IANA registry of link relations for practically the entire book. It’s
            a global registry containing about 60 link relations. You’re allowed to use any IANAregistered relation in
            any representation, and to assume that your clients know what you’re talking about.

            In step 3 of Chapter 9’s design procedure, I mention several IANA-registered link rela‐
            tions that are especially useful for API design.

        The Microformats Wiki
            The Microformats project was the first successful attempt at defining profiles for ap‐
            plication semantics. Microformats are defined collaboratively, on a wiki and mailing
            list. Of the stable microformats, these are the ones you’re most likely to be interested in

            hCalendar
            hCard
            XFN
                A set of link relations describing relationships between people, ranging from friend
                to colleague to sweetheart.
            XOXO
            adr
            geo
            hAtom
            hMedia
                Basic metadata about image, video, and audio files
            hProduct
                Product listings.
            hRecipe
                Recipes.
            hResume
                Resumes/CVs.
            hReview
                Describes a review (of anything), with a rating

        Link Relations from the Microformats Wiki

        schema.org
            There are hundreds of microdata items described on schema.org, and more are on the
            way as the schema.org maintainers work with the creators of other standards to repre‐
            sent those standards in microdata.

            • CreativeWork (including Article, Blog, Book, Comment, MusicRecording, Soft‐
            wareApplication, TVSeries, and WebPage)
            • Event (including BusinessEvent, Festival, and UserInteraction)
            • Intangible is sort of a catch-all category, which notably includes Audience, Brand,
            GeoCoordinates, JobPosting, Language, Offer, and Quantity
            • MedicalEntity (including MedicalCondition, MedicalTest, and AnatomicalStruc‐
            ture)
            • Organization (including Corporation, NGO, and SportsTeam)
            • Person
            • Place (including City, Mountain, and TouristAttraction)
            • Product (including ProductModel)

===============================================================================================================
===============================================================================================================
Chapter  11 - HTTP for APIs    !!!!!!!!!!! (lots of good tips in this chapter as well)

!!! Think of the World Wide Web (and of any other RESTful API) as a technology stack.
    URLs are on the bottom; they identify resources. The HTTP protocol sits on top of those
    resources, providing read access to their representations and write access to the under‐
    lying resource state. Hypermedia sits on top of HTTP, describing the protocol semantics
    of one particular website or API.

!!! The bottom layer answers the question “Where is the resource?” The middle layer an‐
    swers the question “How do I communicate with the resource?” The top layer answers
    the question “What next?”

    So far, this book has focused on the top layer of the stack—“What next?” That’s because
    the top layer is the tricky one. Most of today’s APIs use URLs and HTTP correctly, but
    don’t even bother with hypermedia.

    I don’t want to explain the HTTP protocol in detail; for that, I recommend HTTP: The Definitive Guide, by David Gourley

    I’ll focus on features of HTTP that are especially useful in APIs, and
    features that new API developers may not be aware of.

    Response Codes
        Some of them are useless for our purposes,
        but collectively, they represent a basic set of semantics, defined in the most fundamental
        of all API standards. There’s no excuse for ignoring this gift. If you reinvent 404 (Not
        Found) or 409 (Conflict) for your API, you’re just creating more work for everybody.
        Use your response codes.

!!!     If a client sends some bad data to your API, you should send the response code 400 (Bad
        Request) and an entity-body explaining what the problem is. Don’t send 200 (OK) with
        an error message. You’re lying to the client. You’ll have to write extra documentation
        explaining that in your API, OK sometimes doesn’t mean “OK.”

    Headers
        A few headers correspond to features of HTTP that are important to APIs: notably,
        content negotiation and conditional requests. I’ve given these features their own sections
        in this chapter
        I also cover a number of useful extensions: notably, the Link header, which you’ve seen
        already.

    Choosing Between Representations
        How does a client signal whether it wants English
        or Spanish, XML or JSON, overview or detail? There are two main strategies.

    Content Negotiation
        The client can use special HTTP request headers to tell the server which representations
        it wants. This process is called content negotiation, and the HTTP standard defines five
        request headers for it. They’re collectively called the Accept-* headers. I’ll cover all five
        in Appendix B, but here I want to highlight the two most important: Accept and AcceptLanguage.

        Most web API clients only understand a single media type. When they make a request,
        they send a simple Accept header, asking for that media type:
            Accept: application/vnd.collection+json
        The client tells the server that it only understands Collection+JSON. If the server has
        the option of serving Atom or Collection+JSON, it should serve Collection+JSON.

!!!!    When I make an HTTP request from my web browser, it sends a much more complicated
        Accept header:
            Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
        RFC 2616 gives the complex details of what can go into an Accept-* header, but this
        real-life example serves as a good indicator of what’s possible. The main job of a web
        browser is to display web pages, so my browser gives top priority to HTML represen‐
        tations (the text/html media type) and XHTML representations (application/
        xhtml). My browser can also display raw XML (application/xml), but since that doesn’t
        look as nice, XML is given a lower priority than HTML (q=0.9). If neither HTML nor
        XML representations are available (maybe because the resource is a binary image), my
        browser will accept any media type at all (*/*). But that’s a last-ditch option, and it’s
        given the lowest priority of all (q=0.8).

        My web browser also has a setting for language preferences: which languages I’d prefer
        to get web pages in. With every HTTP request I make, my browser transforms my
        language preferences into a value for the Accept-Language header:
            Accept-Language: en-us,en;q=0.5

!!!!    If the server can’t fulfill a request due to Accept-* restrictions, it can send the response
        code 406 (Not Acceptable).

    Negotiating a profile
        In Chapter 8, I kind of dismissed the profile media type parameter, because not many
        media types support it, but it has a big advantage in content negotiation. When a media
        type supports the profile parameter, you can use content negotiation to ask for a spe‐
        cific profile. Here’s a client that wants an XHTML representation that uses the hCard
        microformat:
            Accept: application/xml+xhtml;profile="http://microformats.org/wiki/hcard"

        You can’t do that if the profile is conveyed through the Link header. And, of course, you
        can’t do it if the media type doesn’t support the profile parameter.

    Hypermedia Menus
!!!!    you can give each representation its own URL, effectively making it an
        independent resource.
        A server offers a choice between these resources by sending the response code 300
        (Multiple Choices). The entity-body should contain a hypermedia document that
        links to the different choices.
        If you do it this way, you’ll need to use a hypermedia format
        capable of explaining what sort of thing is on the other end of a link. Otherwise, your
        clients will have no way of deciding which link to click.

        HTML’s <a> and <link> tags have good support for this, with the type attribute:
            <a href="/resource/siren" type="application/vnd.siren+json" rel="alternate">
             The Siren version.
            </a>
            <a href="/resource/html" type="text/html" rel="alternate">
             The HTML version.
            </a>

        The hreflang attribute is a hint as to the language at the other end of the link:
            <a href="/resource.es" hreflang="es">
             Para la versión en español, haga clic aquí.
            </a>

        Since most hypermedia formats don’t have these features, I generally recommend
        header-based content negotiation for this

    The Canonical URL
        Whenever a resource has more than one URL, you should identify one of them as the
        official or canonical URL: the one clients should use when talking about the resource
        rather than sending HTTP requests to it.

        There are two ways of doing this. First, you can use the standard HTTP header ContentLocation as a hypermedia
        control that points to the current resource’s canonical URL.
        There’s also the IANA-registered link relation canonical, which serves the same pur‐
        pose. You can use canonical within a representation or in the Link header.

!!!
    HTTP Performance
        HTTP clients are allowed to make whatever HTTP requests they want, whenever they
        want. But some requests turn out to be pointless wastes of time. HTTP defines several
        optimizations for discouraging requests that are likely to be pointless (caching), for
        reducing the cost of a request that turns out to be pointless (conditional requests), and
        for reducing the cost of a request in general (compression).

!!!!
    Caching
        I’m going to focus on the simplest way to add caching to web APIs,
        using the HTTP header Cache-Control.
        For anything more complex, I’ll refer you to HTTP: The Definitive Guide, and to the Internet-Draft
        “draft-ietf-httpbisp6-cache,” which is part of the current effort to replace RFC 2616.

            HTTP/1.1 200 OK
            Content-Type: text/html
            Cache-Control: max-age=3600
            ...

        The max-age directive says how long the client should wait before making this HTTP
        request again. If a client gets this response and half an hour later, it wants to send the
        request again, it should hold off. The server said to check back in an hour (3,600 sec‐
        onds), and not before

        A caching directive applies to the entire HTTP response, including the headers and the
        response code, not just to the entity-body. The idea is that if the client really needs to
        look at an HTTP response, it should look at the cached response instead of making the
        request again

        Another common use of Cache-Control is for the server to tell the client not to cache
        a response, even if it would otherwise:
            HTTP/1.1 200 OK
            Content-Type: text/html
            Cache-Control: no-cache
            ...
        This indicates that the resource state is so volatile that the representation probably be‐
        come obsolete during the time it took to send it

!!!     For representations that consist entirely of hypermedia controls, representations that
        only change when you upgrade your API implementation, it makes sense to set maxage pretty high. Or you can use…

!!!!!
    Conditional GET
        Sometimes you just don’t know when a resource’s state will change. (Collection-type
        resources are the worst for this.) It might change all the time, or it might change so rarely
        that you can’t estimate how often a change happens.

        This client-side feature is called a conditional request, and to support it, you’ll need to
        serve the Last-Modified or ETag header with your representations (better yet, serve
        both). The Last-Modified header tells the client when the state of this resource last
        changed. Here it is in an example HTTP response:
            HTTP/1.1 200 OK
            Content-Length: 41123
            Content-type: text/html
            Last-Modified: Mon, 21 Jan 2013 09:35:19 GMT
            <html>
            ...

        The client makes a note of the Last-Modified value, and the next time it makes a request,
        it puts that value in the HTTP header If-Modified-Since:
            GET /some-resource HTTP/1.1
            If-Modified-Since: Mon, 21 Jan 2013 09:35:19 GMT
        If the resource state has changed since the date given in If-Modified-Since, then
        nothing special happens. The server sends the status code 200, an updated LastModified, and a full representation:
            HTTP/1.1 200 OK
            Content-Length: 44181
            Content-type: text/html
            Last-Modified: Mon, 27 Jan 2013 07:57:10 GMT
            <html>
            ...
        But if the representation hasn’t changed since the last request, the server sends the status
        code 304 (Not Modified), and no entity-body:
            HTTP/1.1 304 Not Modified
            Content-Length: 0
            Last-Modified: Mon, 27 Jan 2013 07:57:10 GMT
!!!!    This saves both parties time and bandwidth. The server doesn’t have to send the rep‐
        resentation and the client doesn’t have to receive it. If the representation was one that
        gets dynamically generated from the resource state, a conditional request also saves the
        server the effort of generating the representation

!!!     Of course, this means some extra work for you. You’ll need to track the last-modified
        date of all your resources. And remember that the value for Last-Modified is the date
        the representation changed. If you have a collection resource whose representation in‐
        cludes bits of other representations, that resource’s Last-Modified represents the last
        time any of that stuff changed.

        There’s another strategy that is easier to implement than Last-Modified, and that avoids
        some race conditions. The ETag header (it stands for “entity tag”) contains a nonsensical
        string that must change whenever the corresponding representation changes.
        Here’s an example HTTP response that includes ETag:
            HTTP/1.1 200 OK
            Content-Length: 44181
            Content-type: text/html
            ETag: "7359b7-a37c-45b333d7"
            <html>
            ...
        When the client makes a second request for the same resource, it sets the If-NoneMatch header to the ETag it got
        in the original response:
            GET /some-resource HTTP/1.1
            If-None-Match: "7359b7-a37c-45b333d7"
        If the ETag in If-None-Match is the same as the representation’s current ETag, the server
        sends 304 (Not Modified) and an empty entity-body. If the representation has changed,
        the server sends 200 (OK), a full entity-body, and an updated ETag.
        Serving Last-Modified requires that you keep track of a lot of timestamps, but you can
        generate ETags for representations without tracking any extra data at all. A transfor‐
        mation like the MD5 hash can turn any string of bytes into a short string that’s reliably
        unique.

        The problem is, by the time you can run one of those transformations, you’ve already
        created the representation as a string of bytes. You may end up saving bandwidth by not
        sending the representation over the wire, but you’ve already done the work necessary
        to build it. Using ETag to save time, as opposed to bandwidth, requires that you cache
        a representation’s ETag and invalidate the cache when the representation changes.

        Either Last-Modified or ETag will give you support for conditional requests, but serving
        both would be ideal, and ETag is more reliable than Last-Modified.

    Look-Before-You-Leap Requests
        Another feature of HTTP, less often used, can save the
        client from fruitlessly sending enormous (or sensitive) representations to the server.
        There’s no official name for this kind of request, so the original RESTful Web Services
        introduced a silly name—look-before-you-leap requests—which seems to have stuck.

        To make a LBYL request, a client sends an unsafe request such as a PUT, omitting the
        entity-body. The client sets the Expect request header to the literal string 100-
        continue. Here’s a sample LBYL request:
            PUT /filestore/myfile.txt HTTP/1.1
            Host: example.com
            Content-length: 524288000
            Expect: 100-continue

        This is not a real PUT request: it’s a question about a possible future PUT request. The
        client is asking the server: “would you allow me to PUT a new representation to /filestore/
        myfile.txt? The server makes its decision based on the current state of that resource, and
        the HTTP headers provided by the client. In this case, the server would examine
        Content-Length and decide whether it’s willing to accept a 500 MB file.

        If the answer is yes, the server sends a status code of 100 (Continue). Then the client is
        expected to resend the PUT request, omitting the Expect and including the 500 MB
        representation in the entity-body. The server has agreed to accept that representation.
        If the answer is no, the server sends a status code of 417 (Expectation Failed). The
        answer might be no because the resource at /filestore/myfile.txt is write-protected, be‐
        cause the client didn’t provide the proper authentication credentials, or because 500 MB
        is just too big. Whatever the reason, the initial look-before-you-leap request has saved
        the client from sending 500 MB of data only to have that data rejected. Both client and
        server are better off.

        Of course, a client with a bad representation can lie about it in the headers just to get a
        status code of 100, but it won’t do any good. The server won’t accept a bad representation
        on the second request, any more than it would have on the first request. The client’s
        massive upload will probably be interrupted by response code 413 (Request Entity
        Too Large).

    Compression
        Textual representations like JSON and XML documents can be compressed to a fraction
        of their original size. An HTTP client library can request a compressed version of a
        representation and then transparently decompress it for its user.

        Here’s how it works. When a client sends a request, it includes an Accept-Encoding
        header that says which compression algorithms the client understands. The IANA keeps
        a registry of acceptable values at this IANA page (it’s the list of “content-codings”), but
        the value you want to use is gzip:
            GET /resource.html HTTP/1.1
            Host: www.example.com
            Accept-Encoding: gzip

        If the server understands one of the compression algorithms mentioned in AcceptEncoding, it can use that algorithm
        to compress the representation before serving it.
        The server sends the same Content-Type it would send if the representation wasn’t
        compressed. But it also sends the Content-Encoding header, so the client knows the
        document has been compressed:
            HTTP/1.1 200 OK
            Content-Type: text/html
            Content-Encoding: gzip
            [Binary representation goes here.]

!!!!    The client decompresses the data using the algorithm given in Content-Encoding, and
        then treats it as the media type given as Content-Type. In this case, the client would use
        the gzip algorithm to decompress the binary data back into an HTML document. As
        far as the client is concerned, it asked for HTML and it got HTML. This technique can
        save a lot of bandwidth, with very little cost in additional complexity.

    Partial GET
        HTTP partial GET allows a client to fetch only a subset of a representation. It’s usually
        used to resume interrupted downloads. Most web servers support partial GET for static
        content. If your API serves big static files, it’s worth the effort to support partial GET
        on them.

        A resource that supports partial GET advertises this fact in response to a normal GET,
        by setting the Accept-Ranges response header to the literal string bytes. Here’s the
        response to a successful GET request for a very large video file:
            HTTP/1.1 200 OK
            Content-Length: 1271174395
            Accept-Ranges: bytes
            Content-Type: video/mpeg
            [Binary representation goes here.]
        If the download is interrupted, a client that supports partial GET can resume the down‐
        load from the point of interruption, rather than starting over. Here’s a request for just
        the last kilobyte of that video file:
            GET /large-video-file
            Range: 1271173371-
        The response would look like this:
            206 Partial Content
            content-Type: video/mpeg
            Content-Range: 1271173371-1271174395
            Content-Length: 1024
            [Binary representation goes here.]

    Avoiding the Lost Update Problem
        I introduced ETag and Last-Modified as a way of saving time and bandwidth when
        making GET requests. But conditional requests are also useful as a way of avoiding data
        loss when using unsafe HTTP methods like PUT and PATCH.

        (EXAMPLE 2 users that modify the same resource with PUT without being aware of each other...only the last request
        will remain, and the first will be lost)

        This sort of tragedy can be avoided by making unsafe requests conditional. With con‐
        ditional GET, we wanted the request to go through only if the representation had
        changed. Here, Bob wants his PUT request to go through only if the representation has
        not changed. The technique is the same, but the conditional is reversed. Instead of IfMatch, the client uses
        the opposite header, If-None-Match. Instead of If-ModifiedSince, the client uses If-Unmodified-Since.

 !!!    Instead of 200 (OK), the server would have sent the status code 412 (Precondition
        Failed). Bob’s client would then know that someone else had modified the grocery list.
        Instead of overwriting the current representation, Bob’s client could send a GET request
        for the new representation, and try to merge it with Bob’s version. Or it could escalate
        the issue and ask Bob to deal with it himself. It depends on the media type and the
        application.

!!!     In my opinion, your API implementations should require clients to make conditional
        PUT and PATCH requests. If a client tries to make an unconditional PUT or PATCH,
        you should send the status code 428 (Precondition Required).

!!!!!
    Authentication
        For simplicity’s sake, the examples I’ve presented throughout this book don’t require
        any kind of authentication. You make an HTTP request, and you get a response. There
        are plenty of real APIs like this, but most APIs require authentication.

        There are two steps to authentication. Step 1 is a one-time step in which a user sets up
        her credentials with the service provider. Usually this means a human being using her
        web browser to create an account on the API server, or tying in some existing user
        account on a website with the API server.

        Step 2 is the automated presentation of the user credentials along with each request to
        the API.
!!!     Why present the user credentials along with every HTTP request? Because of the state‐
        lessness constraint, which allows the server to completely forget about a client between
        requests. There are no sessions in a RESTful server implementation.

        Some authentication techniques also include a “step zero” called registration. Here, a
        developer uses her web browser to set up credentials for a software client she is writing.
        If a thousand people end up using that client, each will have to set up her own personal
        user credentials (step 1), but they will all share a set of client credentials. When an API
        adopts this technique, a client that wants to make an HTTP request must present both
        its client credentials and a set of user credentials

    The WWW-Authenticate and Authorization Headers
        I’m about to cover three popular authentication techniques. First I’ll talk about what all
        three have in common: HTTP’s authentication headers.

        Our story begins, as it did in Chapter 1, with our heroine Alice making a simple request
        for a representation:
            GET / HTTP/1.1
            Host: api.example.com
        But this time, the server refuses to serve the requested representation. Instead, it serves
        an error:
            401 Unauthorized HTTP/1.1
            WWW-Authenticate: Basic realm="My API"
        The 401 response code is a demand for authorization. The WWW-Authenticate header
        explains what sort of authorization the server will accept. In this case, the server wants
        the client to use HTTP Basic authentication.
        Alice needs to get some credentials… somehow. The details depend on the authentica‐
        tion mechanism in use. Once she’s got her credentials she can make the HTTP request
        again, sending her credentials in the Authorization request header:
            GET / HTTP/1.1
            Host: api.example.com
            Authorization: Basic YWxpY2U6cGFzc3dvcmQ=
        This time, the server will hopefully give Alice the representation she asked for.

    Basic Auth
        HTTP Basic authentication is described in RFC 2617. It’s a simple username/password
        scheme. The user of an API is supposed to set up a username and password ahead of
        time—probably by registering an account on an affiliated website, or by sending an
        email requesting an API account. There’s no standard for how to request a username
        and password for a given site.

        However it happens, once Alice has her username and password, she can make that
        original HTTP request again. This time she uses her username and password to generate
        a value for the request header Authorization, as seen in the previous section

        Basic Auth is simple, but it has two big problems. The first is that it’s not secure. YWx
        pY2U6cGFzc3dvcmQ= looks like encrypted gibberish, but it’s actually the string
        alice:password run through a simple, reversible transform called Base64.2 This means
        that anyone spying on Alice’s Internet connection now knows her password. They can
        impersonate Alice by sending HTTP requests that include Authorization: Basic YWx
        pY2U6cGFzc3dvcmQ=.

        This problem goes away if the API uses HTTPS instead of plain HTTP. Someone spying
        on Alice’s Internet connection will see her open a connection, but the request and re‐
        sponse will be encrypted by the SSL layer

    OAuth 1.0
        Under OAuth, Alice gives each client (API client) an individual set of credentials. If she decides she
        doesn’t like one of the clients, she revokes its credentials, and the other nine clients are
        unaffected. If a client goes rogue and starts posting spam under the names of its users,
        the service provider can step in and revoke the credentials for every instance of that
        client—Alice’s and everyone else’s.

        There are two versions of OAuth. OAuth 1.0 (defined in RFC 5849) works well for
        allowing the developers of consumer-facing websites to integrate with your API. It starts
        falling apart when you want to allow the integration of desktop, mobile, or in-browser
        applications with your API. OAuth 2.0 is very similar to 1.0, but it defines ways to handle
        these scenarios

        I’m going to briefly describe the concepts behind OAuth using OAuth 1.0, and point
        you to Ryan Boyd’s Getting Started with OAuth 2.0 (O’Reilly) for a readable, detailed
        explanation of OAuth 2.0.

        Here’s what a 401 response code looks like when the server wants a client to provide a
        set of OAuth credentials:
            HTTP/1.1 401 Unauthorized
            WWW-Authorization: OAuth realm="My API"

        Obtaining those credentials is an elaborate process. Let’s suppose Alice is using a website,
        YouTypeItWePostIt.com. She sees a hypermedia control that tells her she can integrate
        her account on Example.net with her account on YouTypeItWePostIt.com. She can do
        this without telling YouTypeItWePostIt.com her password on Example.net (see
        Figure 11-2).

        How OAuth 1 works ?
            1. The YouTypeItWePostIt.com server secretly requests a set of temporary creden‐
            tials from the API provider, api.example.net. This step does not require Alice’s in‐
            volvement at all.
            2. The YouTypeItWePostIt.com server sends an HTTP redirect to Alice’s browser.
            Alice leaves the website she was using, and ends up on a web page served by the
            API provider, Example.net.
            If Alice is not already logged in on Example.net, she needs to log in or create a user
            account. This means entering her password—but note that she’s giving her Exam‐
            ple.net password to api.example.net, not to YouTypeItWePostIt.com.
            3. After logging in, Alice sees a web page that is tied to the temporary credentials
            obtained in step 1. The human-readable text of the page explains to Alice what’s
            going on, and asks her if she wants to authorize a set of api.example.net token
            credentials for YouTypeItWePostIt.com (see Figure 11-3).
            4. Alice makes her decision and her browser is redirected back to YouTypeItWePos‐
            tIt.com, the site she was using originally.
            5. a) If Alice said “no” in step 4, the client is out of luck. It won’t be getting any
            api.example.net token credentials from Alice.
            b) If Alice said “yes” in step 4, the client is allowed to exchange the temporary
            credentials obtained in step 1, for a set of real token credentials. These credentials
            can be used to cryptographically sign HTTP requests, generating Authorization
            headers like the one in this request:
                GET / HTTP/1.1
                Host: api.example.net
                Authorization: OAuth realm="Example API",
                 oauth_consumer_key="rQLd1PciL0sc3wZ",
                 oauth_signature_method="HMAC-SHA1",
                 oauth_timestamp="1363723000",
                 oauth_nonce="JFI8Bq",
                 oauth_signature="4HBjJvupgIYbeEy4kEOLS%Ydn6qyV%UY"

        You can see that OAuth is a lot more complicated than HTTP Basic Auth, but—I can’t
        stress this enough—it keeps Alice from having to give her password to 10 different pieces
        of software she doesn’t trust.

    Where OAuth 1.0 Falls Short
        OAuth 1.0 works great when all the action happens inside Alice’s web browser. What if
        Alice is using a desktop application?
        In that case, Alice needs to switch to her web browser temporarily. In step 2, instead of
        redirecting Alice to the page on api.example.net, the desktop application opens a new
        browser window set to that page. Once Alice makes her decision in step 4, there’s no‐
        where for api.example.net to redirect her back to. In the background, the desktop ap‐
        plication needs to be continually asking api.example.net whether Alice has authorized
        (or denied) the temporary credentials.

        That’s OAuth 1.0’s answer for integrating an API into a desktop application without
        requiring a username/password entry. It’s a little disruptive to have a web browser win‐
        dow suddenly pop up when you’re using a desktop application, but it’s doable.

    OAuth 2.0
        OAuth 2.0 is defined in RFC 6749. It specifies four different processes for getting an
        OAuth access token (again, I won’t go into a lot of detail; see Getting Started with OAuth
        2.0 to learn more):
            • By providing an “authorization code” (section 1.3.1 of RFC 6749). This is the system
            I described for OAuth 1.0. The “resource owner” (Alice) authenticates with an “au‐
            thorization server” (logs in to Example.net), which redirects her to the “client”
            (api.example.net), which gives out the access token.
            • Through an “implicit grant” (section 1.3.2 of RFC 6749). This is a good choice for
            an application that runs inside Alice’s web browser. After Alice logs in to Exam‐
            ple.net, she’s redirected to api.example.net, which redirects her to a URL containing
            the access token. There’s no need to get temporary credentials; the in-browser ap‐
            plication can just read the access token out of the browser’s address bar.
            • Through “resource owner password credentials” (section 1.3.3 of RFC 6749). That
            is, Alice provides her Example.net username and password to the client, which
            exchanges them for an OAuth access token.
            This is exactly what OAuth is trying to avoid: Alice giving up her password to an
            untrusted client. But on a mobile device or a game console, there’s no good alter‐
            native.
            At this point, a malicious client can steal Alice’s password. But a legitimate client
            will forget Alice’s password as soon as it gets an OAuth access token. This means
            that a legitimate client won’t break if Alice changes her password for other reasons.
            • Through “client credentials” (section 1.3.4 of RFC 6749). This saves a lot of aggra‐
            vation when Alice is the author of her own client. When Alice registers her client
            with api.example.net, she’s automatically given a set of credentials that will give her
            client free access to her own example.net account.

!!!!   As an API provider, you don’t have to implement all four of these application flows. If
       you’re writing an API to serve as a backend for a mobile application, you can just im‐
       plement the “resource owner password credentials” flow. But if you want third parties
       to integrate clients with your API, you’ll need to implement the application flows your
       clients want to use.

        If you understand the security issues, but you just don’t think your API will ever become
        popular enough for malicious clients to be a problem, you should go with OAuth anyway.
        Once you start using HTTP Basic, it’s very difficult to switch all your clients to OAuth.
        Don’t lock yourself out of success.(When the Twitter API switched from Basic Auth to OAuth in 2010, developers
        dubbed the event the “OAuth-pocalypse.”)

    Extensions to HTTP
        There are two extensions to HTTP that define new methods specifically for use in APIs,
        and three major protocols that take HTTP as their starting point. One of those protocols,
        CoAP, is so unusual that I’m dedicating an entire chapter (Chapter 13) to it. WebDAV
        and HTTP 2.0 are closely based on HTTP, so I’m covering them here, along with a few
        extension HTTP methods.

    The PATCH Method
        The PATCH method solves a performance problem with HTTP PUT. PUT replaces a
        resource’s entire representation with a new one, which means the client must resend the
        entire representation even if it’s only making a small change. The PATCH method lets
        the client send only the change it wants to make.
        The downside of the PATCH method is that client and server must agree on a new media
        type for patch documents. Fortunately, you don’t have to come up with this format
        yourself. RFC 6902 defines a standard patch format for JSON, and registers the media
        type application/json-patch for documents in that format.

    WebDAV
        The goal of WebDAV is to make it easy to publish HTTP resources for files and direc‐
        tories on a remote filesystem. WebDAV defines so many new HTTP methods and other
        extensions that it can almost be considered a different protocol

        The highest profile uses of WebDAV are Microsoft’s Sharepoint and the Subversion
        version control system. We don’t really think of those as APIs, and most APIs that act
        like remote filesystems (Amazon’s S3, the Dropbox API, and so on) don’t use WebDAV.

    HTTP 2.0
        HTTP 2.0 is based on SPDY, a corporate standard defined by Google
        that adds a performance layer on top of HTTP. Most web browsers now support SPDY,
        and many large sites serve data using SPDY if the client supports it.

        Despite its imposing name, HTTP 2.0 won’t bring in new features that shake
        the foundations of API design. Whether you’re developing an API, an API client, or a
        website, you should be able to pretend you’re using HTTP 1.1, and let a compatibility
        layer automatically convert between HTTP 1.1 and 2.0.

        It may end up looking nothing like SPDY. But it needs to solve the problems
        SPDY solves, which means it will probably have these two features:
            • HTTP 2.0 will save bandwidth by compressing HTTP headers, something that’s not
            legal under HTTP 1.0.
            • An HTTP 2.0 client will be able to send multiple simultaneous requests (“streams”)
            to a server over a single TCP connection. This is similar to the pipelining feature
            of HTTP 1.1, but as I mentioned earlier, pipelining doesn’t help performance very
            much. HTTP 2.0 needs to include a pipelining-like feature that actually works.

===============================================================================================================
===============================================================================================================
Chapter  12 - Resource Description and Linked Data

    The data formats I’ve covered in this book are used primarily to allow resources to talk
    about themselves. That is, a client sends a GET request to the URL of a resource and
    receives a representation of that very resource. I’m calling this the representation strategy

    But a representation of resource A may also have something to say about resource B.
    This simple Collection+JSON document is a representation of one resource (a collec‐
    tion) but it has something to say about two other resources (the items in the collection):

    I’m calling this the description strategy. With the description strategy, a representation
    spends most of its time talking about resources other than the resource it’s a represen‐
    tation of.

    All hypermedia formats mix the representation and description strategies to some ex‐
    tent, but there’s a family of formats that focuses heavily on the description strategy:
    formats inspired by the Resource Description Framework (RDF) data model and asso‐
    ciated with the Semantic Web movement

    Fortunately, a second-wave Semantic Web movement called Linked Data aims to refocus
    RDF on the representation strategy. This is great news, because there are several useful
    data formats derived from RDF, and a very powerful language for creating machinereadable profiles: RDF Schema.

    The Linked Data Movement
        Web philosophy closer to the REST philosophy. Here are
        Berners-Lee’s four principles of Linked Data:
            1. Use URIs as names for things.
                In REST terms, this says that a URI identifies a resource. In Chapter 1, I called this the
                principle of addressability.
            2. Use HTTP URIs so that people can look up those names.
                This has two parts. First, you shouldn’t identify your resources with URIs like urn:isbn:
                9781449358063. You should use URLs like http://example.com/books/9781449358063.
                It’s true that urn:isbn:9781449358063 is a much more general way to refer to the resource,
                but because it’s so general, a client can’t do anything with the reference.
                Second, resources should have representations. A client that sends a GET request to a
                URL should get some useful data in return. A URL like http://vocab.org/vnd/
                mamund.com/2013/numbers/primes looks good, right up to the point when you send a
                GET request to it and get a 404 error. Then you find out that the URL was actually a
                URI. It has no representation. There may be a magical document somewhere that de‐
                scribes that URI, but good luck finding it.
            3. When someone looks up a URI, provide useful information, using the standards (RDF*, SPARQL).
                Again, resources have representations. A client that sends a GET request to a resource’s
                URL should receive a document capturing the current state of the resource.
                The exact standards don’t matter (I’m not even covering SPARQL in this book). What
                matters is that you use some standard, instead of making up a custom data format. That
                way, a client that understands your standard automatically knows how to handle the
                data you provide—at least on a basic level. This is a theme I’ve been hitting throughout
                this book: you should use an existing hypermedia format instead of defining your own.
            4. Include links to other URIs. so that they can discover more things.
                And finally, the big payoff: the hypermedia constraint. A URI is now a URL, a link,
                which a client can follow to get a representation. That representation will contain other
                links, and the client can follow them to get closer to fulfilling whatever desire it was
                programmed with.

!!!!    If you want to write a Linked Data API, I suggest you use JSON-LD as your represen‐
        tation format instead of RDF/XML or RDF/Turtle. JSON-LD is a new serialization of
        RDF designed specifically for making APIs that resemble today’s other hypermedia
        APIs.

    JSON-LD
        In Chapter 8, I covered JSON-LD as a profile format. I showed how a bare JSON representation…
            HTTP/1.1 200 OK
            Content-Type: application/json
            { "n": "Jenny Gallegos",
             "photo_link": "http://api.example.com/img/omjennyg" }
        …could be transformed into a hypermedia document by the addition of a JSON-LD “context”:
            HTTP/1.1 200 OK
            Content-Type: application/ld+json
            {
             "@context":
             {
             "n": "http://alps.io/schema.org/Person#name",
             "photo_link":
             {
             "@id": "http://alps.io/schema.org/Person#image",
             "@type": "@id"
             }
             }
            }

    JSON-LD as a Representation Format
        So far, I’ve presented JSON-LD as a sort of profile format: an add-on to a plain JSON
        document that explains its application semantics. You use the Link header to connect
        the JSON document to its JSON-LD context:
            Link: <http://api.example.com/profile.person.jsonld>; rel="http://www.w3.org/ns/json-ld#context"
        It’s not quite accurate to say that JSON-LD is a profile format

        And JSON-LD isn’t limited to this add-on role. Any JSON object becomes a JSON-LD
        document if you add a @context property and serve it as application/ld+json. This
        means you can combine the JSON-LD context with the data you’re serving, and serve
        the whole thing at once:

            HTTP/1.1 200 OK
            Content-Type: application/ld+json
            {
             "n": "Jenny Gallegos",
             "picture_link": "http://www.example.com/img/omjennyg",
             "@type": "http://schema.org/Person",
             "@context":
             {
                "n": "http://schema.org/name",
                "photo_link":
                {
                    "@id": "http://schema.org/image",
                    "@type": "@id"
                }
             }
            }

        At this point, JSON-LD becomes a traditional hypermedia format. The Link header is
        no longer necessary, because there’s only one document

!!!     But as representation formats go, JSON-LD isn’t very capable. Thanks to its RDF her‐
        itage, JSON-LD can describe application semantics in great detail, but its protocol se‐
        mantics are very limited. A Linked Data client can do nothing but follow links from one
        bit of data to another. A client can’t change the data, because JSON-LD has no hyper‐
        media controls for triggering unsafe HTTP requests.
        If you want to use JSON-LD in your API, I recommend you also use an extension called
        Hydra.

    Hydra
        derived from JSON-LD; implements the collection pattern
        (“collection” and “resource”), but collections have no special protocol semantics

        Hydra is a JSON-LD context that adds a lot of protocol semantics to JSON-LD. By itself,
        JSON-LD only lets you specify links (using "@type": "@id"), to be triggered with GET
        requests. Add Hydra to the mix, and you can specify almost any HTTP request.

        But there’s a strong temptation to confuse “the abstract semantic type of a resource”
        with “the implementation details of a class in my data model.” Hydra contexts, OData
        metadata documents, and WADL documents tempt server-side API developers into
        automatically generating one-off vocabularies based on their internal data models, in‐
        stead of reusing standard vocabularies

    The Ontology Zoo
        This is a follow-up to Chapter 10’s “The Semantic Zoo” on page 230, listing some RDF
        Schema vocabularies of interest. There are a lot of RDF Schema vocabularies, but they’re
        scattered all over the Internet. I’m just going to mention two popular vocabularies, and
        one site that collects vocabularies.
        I’ve focused on vocabularies that are likely to be useful in consumer-facing APIs. Most
        of the really heavy-duty vocabularies are used in scientific or medical applications, not
        to describe the semantics of documents served over the Web. Check out the SWEET
        ontologies for a very large vocabulary designed for scientific use.

    Conclusion: The Description Strategy Lives!

===============================================================================================================
===============================================================================================================
Chapter  14 - CoAP: REST for Embedded Systems

    The Constrained Application Protocol is a protocol designed for use in low-power
    embedded environments like home automation systems. CoAP is inspired by HTTP
    and can be used to publish hypermedia-driven RESTful APIs, but it’s a very different
    protocol from HTTP. CoAP brings a web-like architecture to a highly constrained en‐
    vironment: an “Internet of Things” in which a lot of small, cheap computers commu‐
    nicate over a low-capacity network.

    CoAP is designed to live with severe limitations on electricity consumption, network
    bandwidth, and processing power. Its world resembles the ARPAnet of the 1970s rather
    than the network people enjoy today. CoAP requests and responses are very small. On
    a network that runs over home power lines, a CoAP message shouldn’t be larger than
    about 1,024 bytes. On a low-power wireless network, you probably don’t want to go
    above 80 bytes.

    A CoAP Request
        CoAP was designed to operate over UDP, a sister protocol to TCP that doesn’t support con‐
        nections at all. A CoAP client sends a request message to a server, and then goes about
        its business. The client has no idea when the response message, if any, will arrive.

        CoAP defines the four basic HTTP methods (GET, POST, PUT, and DE‐
        LETE), though their semantics are slightly different than in HTTP.

===============================================================================================================
===============================================================================================================
The status codex
    An HTTP status code is a three-digit number attached to an HTTP response. It’s a bit
    of protocol semantics that lets the client know, on the most basic level, what happened
    when the server tried to handle the request. The 41 HTTP response codes defined in
    the HTTP specification form a set of basic protocol semantics that any API can use.

    Apart from HTTP redirects, and the famous “404 Not Found” error page notwith‐
    standing, we don’t really use status codes on the World Wide Web. A human learns what
    happened to a request by reading the entity-body served as part of the response, not by
    looking up a numeric code in the HTTP standard. When you fill out a form on a website,
    but you forget to fill in one of the required fields, the server sends back an error message,
    but the response code associated with the error message is 200 (OK).

    That’s fine. You don’t even see the response code. You read the error message and correct
    the problem. But an API that behaved that way would be lying to its client! Computer
    programs are very good at looking up numeric codes, and very bad at understanding
    prose. When you serve the 200 status code on an error condition, you must write extra
    documentation explaining that in your API, OK doesn’t necessarily mean OK. That extra
    documentation means more work for your users.

    In the world of APIs, then, HTTP response codes become very important. They tell a
    client how to regard the document in the entity-body—whether it’s a representation or
    an error message—or what to do if the client can’t understand the entity-body. A client
    (or an intermediary between server and client, like a proxy or firewall) can figure out
    how an HTTP request went, just by looking at the first few bytes of the response

    In this appendix, I give a brief explanation of each status code, with tips on when to use
    it in your APIs, and my personal opinion as to how important it is to API design. If a
    client must do something specific to get a certain response code, I explain what that is.
    I also list which HTTP response headers, and what kind of entity-body, the server ought
    to send along with a response code. This is an appendix for the API developer, but it’s
    also for the client author, who’s received a strange response code and doesn’t know what
    it means.

    In this appendix, I’ll cover all 41 codes mentioned in RFC 2616, even though some of them (mainly the ones
    to do with proxies) are a little beyond the scope of this book

    I won’t be covering CoAP’s HTTP-inspired status codes (4.04 Not Found), or the HTTP
    status codes defined by extensions like WebDAV. Nor do I cover status codes introduced
    by web server implementations but not formally defined anywhere. These include 509
    (Bandwidth Limit Exceeded), and nginx’s many internal error-reporting codes, like
    499 (Client Closed Request).

!!!!Remember, detailed error reporting is not an excuse for serving 200 (OK) when some‐
    thing’s not OK. The meaning of your representation must always be consistentwith your
    HTTP status code

!!!!!!!
    Families of Status Codes
        The first digit of an HTTP status code is a very general indication of how the request
        went. The HTTP specification defines five families of status codes using the initial digits
        1 through 5. I’ll be covering each of these in a separate section:

        1xx: Informational
            These response codes are used only in negotiations between an HTTP client and server.
        2xx: Successful
            Whatever state transition the client asked for has happened.
        3xx: Redirection
            The state transition the client asked for has not happened. But if the client is willing
            to make a slightly different HTTP request, that request should do what the client
            is asking for.
        4xx: Client Error
            The state transition the client has asked for has not happened, due to a problem
            with the HTTP request. The request was malformed, incoherent, self-contradictory,
            or one that the server cannot accept.
        5xx: Server Error
            The state transition the client has asked for has not happened, due to a problem on
            the server side. There’s probably nothing the client can do but wait for the problem
            to be fixed

!!!!
    Four Status Codes: The Bare Minimum
        I want to list just four that I consider the bare minimum for APIs. There’s one code from each family (apart
        from 1xx, which you can more or less ignore):
            200 (OK)
                Everything’s fine. The document in the entity-body, if any, is a representation of
                some resource.
            301 (Moved Permanently)
                Sent when the client triggers a state transition that moves a resource from one URL
                to another. After the move, requests to the old URL will also result in a 301 status
                code.
            400 (Bad Request)
                There’s a problem on the client side. The document in the entity-body, if any, is an
                error message. Hopefully the client can understand the error message and use it to
                fix the problem.
            500 (Internal Server Error)
                There’s a problem on the server side. The document in the entity-body, if any, is an
                error message. The error message probably won’t do much good, since the client
                can’t fix a server problem

    2xx: Successful
        200 (OK)
            Importance: Very high.
            In most cases, this is the code the client hopes to see. It indicates that the state transition
            is complete, and that no more specific code in the 2xx series is appropriate.

            Entity-body: For a GET request, a representation of the resource that was the target of
            the GET. (This will cause a change in application state.) For other requests, a description
            of the change in resource state: a representation of the current state of the selected
            resource, or a description of the state transition itself.

        201 (Created)
            Importance: High.
            The server sends this status code when it creates a new resource at the client’s request.
            Response headers: The Location header should contain the canonical URL to the new
            resource.
            Entity-body: Should describe and link to the newly created resource. A representation
            of that resource is acceptable, if you use the Location header to tell the client where the
            resource actually lives.

        202 (Accepted)
            Importance: Medium.
            The client’s request can’t or won’t be handled in real time. It will be processed later. The
            request looks valid, but it might turn out to have problems when the server actually gets
            to it.
            This is an appropriate response when a request triggers an asynchronous action, an
            action in the real world, or a state transition that would take so long that there’s no point
            making the client wait around for a response.

        204 (No Content)
            Importance: High.
            This status code is usually sent out in response to an unsafe request such as a PUT
            request. It means that the server has carried out the state transition, but that it declines
            to send back any representation or description of the state transition.
            The server may also send 204 in response to a GET request. This means that the resource
            requested exists, but has an empty representation. Compare 304 (Not Modified).
            204 is often in-browser JavaScript applications. It lets the server tell the client that its
            input was accepted, but that the client shouldn’t change any UI elements.
            Entity-body: Not allowed.

    3xx: Redirection
        The state transition the client asked for has not happened. But if the client is willing to
        make a slightly different HTTP request, that request should do what the client is asking
        for. In general, the client needs to repeat its request to a different resource.
        This is the trickiest set of response codes, because 301 (Moved Permanently), 302
        (Found), 303 (See Other), and 307 (Temporary Redirect), are all very similar. Many
        applications use these status codes indiscriminately as a way of bouncing the client like
        a ball through a hypermedia pinball machine, with little regard for what this means in
        terms of application semantics. My main goal in this section is to clear up the confusion.

        301 (Moved Permanently)
            Importance: Medium.
            The server knows which resource the client is trying to access, but the client doesn’t care
            for the URL it used to request the resource. It wants the client to take note of the new
            URL and use it in future requests.
!!!         You can use this status code to keep old URLs from breaking when your API changes
            its URL structure.
            Response headers: The server should put the canonical URL in Location.
            Entity-body: The server should send a hypermedia document that links to the new lo‐
            cation.

        302 (Found)
            Importance: Very important to know about, especially when writing clients. I don’t rec‐
            ommend using it.
            This response code is still in wide use, but it’s ambiguous,
            and I recommend that your servers send 303, 307, and 308 instead.

        303 (See Other)
            Importance: High.
            The request has been processed, but instead of the server sending a response document,
            it’s sending the client the URL of a response document. This may be the URL of a static
            status message, or of some more interesting resource. In the latter case, a 303 is a way
            for the server to send a representation of a resource without forcing the client to down‐
            load all that data. The client is expected to follow up with a GET request to the URL
            mentioned in Location, but it doesn’t have to.
 !!!!       The 303 status code is a good way to canonicalize your resources. You can make them
            available through many URLs, but only have one “real” URL per representation. All the
            other URLs use a 303 to point to the canonical URL for that representation. For instance,
            a 303 might redirect a request for http://www.example.com/software/current.tar.gz to
            the URL http://www.example.com/software/1.0.2.tar.gz.
            Compare to 307 (Temporary Redirect).
            Response headers: The Location header contains the URL of the representation.
            Entity-body: Should contain a hypermedia link to the new URL, as with 301.

        304 (Not Modified)
            Importance: High.
            This status code is similar to 204 (No Content) in that the response body must be empty.
            But 204 is used when there is no body data to send, and 304 is used when there is data
            but the client already has it. There’s no point in sending it again.
            This status code is used in conjunction with conditional HTTP requests. If the client
            sends an If-Modified-Since header with a date of Sunday, and the representation hasn’t
            changed since Sunday, then a 304 is appropriate. A 200 (OK) would also be appropriate,
            but sending the representation again would waste bandwidth, since the client already has it

        307 (Temporary Redirect)
            Importance: High.
            The request has not been processed, because the requested resource is not home: it’s
            located at some other URL. The client should resubmit the request to another URL.
            For GET requests, where the only thing being requested is that the server send a rep‐
            resentation, this status code is identical to 303 (See Other). A typical case where 307 is
            a good response to a GET is when the server wants to send a client to a mirror site.

            An analogy may help. You go to a pharmacy with a prescription to be filled. A 303 is
            the pharmacist saying “We’ve filled your prescription. Go to the next window to pick
            up your medicine.” A 307 is the pharmacist saying “We’ve run out of that medicine. Go
            to the pharmacy next door.”


    4xx: Client-Side Error
        These status codes indicate that something is wrong on the client side. There’s a problem
        with authentication, with the format of the representation, with the timing of the re‐
        quest, or with the HTTP client itself. The client needs to fix something on its end.
        For most of these error codes I say that the entity-body may contain a “document.” Unless you’re
        using a representation format with a built-in error reporting mechanism, I suggest you
        make that document a problem detail.

        400 (Bad Request)
            Importance: Very high.
            This is the generic client-side error status, used when no other 4xx error code is appro‐
            priate. It’s commonly used when the client submits a representation along with a PUT
            or POST request, and the representation is in the right format, but it doesn’t make any
            sense.
            Entity-body: May contain a document explaining the server’s view of the client-side
            problem.

        401 (Unauthorized)
            Importance: High.
            The client sent a request to a protected resource without providing the proper authen‐
            tication credentials. It may have provided the wrong credentials, or none at all. The
            credentials may be a username and password, an API key, or an authentication token
            —whatever the API in question is expecting. It’s common for a client to make a request
            for a URL and accept a 401 just so it knows what kind of credentials to send and in what
            format. In fact, the HTTP Digest mode of authentication depends on this behavior.

            Entity-body: A document describing the failure; why the credentials (if any were pro‐
            vided) were rejected, and what credentials would be accepted. If a human end-user can
            get credentials by signing up on a website, or creating a “user account” resource, a
            hypermedia link to the sign-up resource is also useful.

        403 (Forbidden)
            Importance: Medium.
            The client’s request is formed correctly, but the server just doesn’t want to carry it out.
            This is not merely a case of insufficient credentials: that would be 401 (Unauthorized).
            This is more like a resource that is only accessible at certain times, or from certain IP
            addresses.

        404 (Not Found)
            Importance: High.
            Probably the most famous HTTP status code. 404 indicates that the server can’t map
            the client’s URL to a resource. Compare 410 (Gone), which is slightly more helpful.
            Remember that a 404 may be a lie to cover up a 403 or 401. It might be that the resource
            exists, but the server doesn’t want to let the client know about it.
            Entity-body: An optional document explaining the error. The document may contain a
            hypermedia control for creating a resource in this spot (probably using HTTP PUT).

        405 (Method Not Allowed)
            Importance: Medium.
            The client tried to use an HTTP method that this resource doesn’t support. For instance,
            a read-only resource may support only GET and HEAD. Collection resources (as de‐
            fined by the collection pattern) generally allow GET and POST, but not PUT or DELETE.

        408 (Request Timeout)
            Importance: Low.
            If an HTTP client opens a connection to the server, but never sends a request (or never
            sends the blank line that signals the end of the request), the server should eventually
            send a 408 response code and close the connection.

        409 (Conflict)
            Importance: Very high.
            The client tried to create an impossible or inconsistent resource state on the server. What
            is “impossible” or “inconsistent” depends on the API’s application semantics. A
            collection-based API may allow a client to DELETE an empty collection, but send 409
            when the client tries to DELETE a collection that still contains members.
            Entity-body: Should contain a document that describes the conflicts, so that the client
            can resolve them if possible.

        412 (Precondition Failed)
            Importance: Medium.
            The client specified one or more preconditions in its request headers, effectively telling
            the server to carry out its request only if certain conditions were met. Those conditions
            were in fact not met, so instead of carrying out the request the server sends this status
            code.
            A common precondition is If-Unmodified-Since. (I covered this in Chapter 11.) The
            client may PUT a request to modify a resource, but ask that the changes take effect only
            if no one else has modified the resource since the client last fetched it. Without the
            precondition, the client might overwrite someone else’s changes without realizing it, or
            might cause a 409 (Conflict)

        428 (Precondition Required)
            Importance: Medium.
            Defined in: RFC 6585.
            In Chapter 11, I recommend that API implementations require that clients make their
            PUT and PATCH requests conditional, as a way of avoiding the lost update problem.
            Web servers enforce that rule with this status code, which says that the client’s request
            is being rejected because it wasn’t made conditional.
            Entity-body: Should contain a document explaining which conditional headers (prob‐
            ably If-Match or If-Unmodified-Since) the server will accept.

        429 (Too Many Requests)
            Importance: Medium.
            Defined in: RFC 6585.
            This status code enforces a server’s rate limiting policy. The client has been sending too
            many requests lately, and needs to back off.
            A server is allowed to simply ignore requests that violate the rate limiting policy, rather
            than respond to each of them with a 429.
            Response headers: The Retry-After header should give a hint as to when the server will
            accept requests from this client again

    5xx: Server-Side Error
        The 5xx series of status codes is for representing problems on the server side. These
        codes usually mean the server is not in a state to carry out the client’s request or even
        see whether it’s correct, and that the client should retry its request later. Sometimes the
        server can estimate when the client should retry its request, and put that information
        into the Retry-After response header.
        There are fewer 5xx status codes than 4xx status codes, not because fewer things might
        go wrong on the server, but because there’s not much point in being specific. The client
        can’t do anything to fix a problem on the server.

             500 (Internal Server Error)
                 Importance: High.
                 This is the generic server error response. Most web frameworks send this status code if
                 they run request handler code that raises an exception.

            503 (Service Unavailable)
                Importance: Medium to high.
                This status code means that the HTTP server is up, but the application underlying the
                API isn’t working properly. The most likely cause is resource starvation: too many re‐
                quests are coming in at once for the API to handle them all.
                Since repeated client requests are probably what’s causing the problem, the HTTP server
                always has the option of refusing to accept a client request, rather than accepting it only
                to send a 503 response code.


===============================================================================================================
===============================================================================================================
The header codex

    HTTP headers are bits of metadata that describe the protocol semantics of an HTTP
    request or response. Some headers, like If-None-Match, are used only in requests.
    They’re the client’s way of telling the server how to handle the request. Some, like
    ETag, are used only in responses. They’re the server’s way of conveying information
    about how the request was processed, or information about the underlying resource
    that’s not present in the representation. Some headers can be used either in a request or
    response, like the all-important Content-Type, which contains the media type of the
    entity-body

    In this appendix, I’m giving a
    somewhat perfunctory description of the standard HTTP headers, with an eye toward
    their use in RESTful APIs, as opposed to other HTTP-based applications like websites
    and HTTP proxies.

    But anyone who runs an HTTP server is allowed to define their own
    HTTP headers. AtomPub defines an HTTP header called Slug (covered in an upcoming
    section). Amazon defines headers like X-amz-acl and X-amz-date for its S3 API.

!!! You probably shouldn’t create a new HTTP header at all.

    The Headers
        I’ll give my opinion as to how useful the header is for APIs. I’ll give a short description of the header, which
        will get a little longer for tricky or especially important headers.

        Accept
            Type: Request header.
            Importance: Medium.
            The client sends an Accept header to tell the server what media types it would prefer
            the server use for its representations. This is the “content negotiation” technique I cov‐
            ered in Chapter 11. One client might want a HAL document in XML format (Accept:
            application/hal+xml); another might want the HAL+JSON representation of the same
            HAL document (Accept: application/hal+json).

        Accept-Encoding
            Type: Request header.
            Importance: Medium to high.
            The client sends an Accept-Encoding header to tell the server that it can save some
            bandwidth by compressing the response entity-body with a well-known algorithm like
            gzip. Despite the name, this has nothing to do with character encodings; that’s AcceptCharset.
            The value of Accept-Encoding is called a “content-coding.” The IANA keeps a registry
            of acceptable content-codings at http://www.iana.org/assignments/http-parameters/
            http-parameters.xml. In general, content-codings are only used to compress data as it
            goes over the wire.

        Authorization
            Type: Request header.
            Importance: Very high.
            This request header contains authorization credentials, such as a username and pass‐
            word, which the client has encoded according to some agreed-upon scheme. The server
            decodes the credentials and decides whether or not to carry out the request.
            This is the only authorization header you should ever need (except for ProxyAuthorization, which works on a
            different level), because it’s extensible. The most
            common schemes are OAuth and HTTP Basic, but the scheme can be anything, so long
            as both client and server understand it.
            There are some other authentication headers that work on top of Authentication,
            notably X-WSSE, but those standards are pretty much dead, so I don’t cover them in this book.

        Cache-Control
            Type: Request and response header.
            Importance: High.
            This header contains a directive to any caches between the client and the server (in‐
            cluding local caches on the client or server machines themselves). It spells out the rules
            for how the data should be cached and when it should be dumped from the cache. This
            is a very complicated header, but I cover the most basic caching directives (“cache” and
            “don’t cache”) in Chapter 11.

        Content-Encoding
            Type: Response header.
            Importance: Medium to high.
            This response header is the counterpart to the request header Accept-Encoding. The
            request header asks the server to compress the entity-body using a certain algorithm.
            This header tells the client which algorithm, if any, the server actually used.
            As with Accept-Encoding, the value of this header is called a “content-coding”, and the
            IANA keeps a registry of acceptable content-codings at http://www.iana.org/assign‐
            ments/http-parameters/http-parameters.xml. In theory, the content-coding could be any
            sort of reversible data transformation, but all the registered content-codings are ways
            of compressing data.

        Content-Length
            Type: Response header.
            Importance: High.
            This response header gives the size of the entity-body in bytes. This is important for
            two reasons: first, a client can read this ahead of time and prepare for a small entitybody or a large one. Second, a client can make a HEAD request to find out how large
            the entity-body is, without actually requesting it. The value of Content-Length might
            affect the client’s decision to fetch the entire entity-body, fetch part of it with Range, or
            not fetch it at all.

        Content-MD5
            Type: Response header.
            Importance: Low to medium.
            This is a cryptographic checksum of the entity-body. The client can use this to check
 !!!        whether or not the entity-body was corrupted in transit. An attacker (such as a manin-the-middle) can change
            the entity-body and change the Content-MD5 header to
            match, so it’s no good for security, just error detection.

!!!!    Content-Type
            Type: Request and response header.
            Importance: Very high.
            The most famous HTTP header, and probably the most important, Content-Type gives
            the media type of the entity-body. The media type serves three purposes:
                • It determines which parser the recipient should use to parse the entity-body.
                • It often determines the representation’s protocol semantics—which parts of the
                representation are hypermedia controls, and what HTTP requests can be triggered
                by activating those controls.
                • It may also determine the representation’s application semantics—what the repre‐
                sentation means in terms of real-world concepts and this specific API.

            There are other ways of conveying application and protocol semantics, such as links to
            profiles, but Content-Type is the main one. This is why it’s such a bad idea to serve
            application/json as your media type. You’re passing up a big opportunity.

        Cookie
            Type: Request header.
            Importance: High on the human web, low in the world of APIs.

            This is probably the second-most-famous HTTP header, after Content-Type, but it’s
            not in the HTTP standard; it’s a Netscape extension.
            A cookie is an agreement between the client and the server where the server gets to store
            some semipersistent state on the client side using the Set-Cookie header (more on this
            in an upcoming section). Once the client gets a cookie, it’s expected to return it with
            every subsequent HTTP request to that server, by setting the Cookie header once for
            each of its cookies. Since the data is sent invisibly in the HTTP headers with every
            request, it looks like the client and server are sharing state.

            Cookies have a bad reputation in REST circles for two reasons. First, the “state” they
            contain is often just a session ID: a short alphanumeric key that ties into a much larger
            data structure on the server. This destroys the principle of statelessness, since application
            state is being kept on the server.
            More subtly, once a client accepts a cookie, it’s supposed to submit it with all subsequent
            requests for a certain time. The server is telling the client that it can no longer make the
            requests it made precookie. This also violates the principle of statelessness.
            If you must use cookies, make sure you store all the state on the client side. Otherwise,
            you’ll lose a lot of the scalability benefits of REST.

        Date
            Type: Request and response header.
            Importance: High for request, required for response.
            As a request header, this represents the time on the client at the time the request was
            sent. As a response header, it represents the time on the server at the time the request
            was fulfilled. The response-header version of Date is used by caches when calculating
            whether a cached document is still fresh

        ETag
            Type: Response header.
            Importance: Very high.
            The value of ETag is an opaque string designating a specific version of a representation.
            Whenever the representation changes, the ETag should also change.
            Servers should send ETag in response to GET requests whenever possible. As I show in
            Chapter 11, clients can make a conditional GET request by sending a previous value of
            ETag as the value of the If-None-Match request header. If the representation hasn’t
            changed, the ETag hasn’t changed either, and the server can save time and bandwidth
            by not sending the representation again.
            The main driver of conditional GET requests is the simpler Last-Modified response
            header, and its request counterpart If-Modified-Since. The main purpose of ETag is
            to provide a second line of defense. If a representation changes twice in one second, it
            will take on only one value for Last-Modified-Since, but two different values for ETag.
            If there’s an intermediary between your server and the client that modifies your repre‐
            sentations (such as Apache’s mod_compress module, which transparently compresses
            representations), that intermediary will also change the value of ETag, in ways that may
            break conditional requests.

        Expires
            Type: Response header
            Importance: Medium.
            This header tells the client, or a proxy between the server and client, that it may cache
            the HTTP response (not just the entity-body!) until a certain time. This is useful because
            even a conditional HTTP GET that ends up doing nothing has the overhead of an HTTP
            request. By paying attention to Expires, a client can avoid the need to make any HTTP
            requests at all—at least for a while.
            It’s usually easier to use the max-age caching directive of the Cache-Control header.
            (That’s the one I covered back in Chapter 11.) That is, it’s easier to say “this representation
            should be good for about an hour” than to calculate the exact time an hour from now.
            But if the server knows exactly when a representation will change (because it changes
            at the same time every hour, every day, or every week), Expires is better.

        Host
            Type: Request header.
            Importance: Required.
            This header contains the domain name part of the request URL. If a client makes a GET
            request for http://www.example.com/page.html, then the URL that actually gets reques‐
            ted is /page.html and the value of the Host header is www.example.com or www.exam
            ple.com:80.
            From the client’s point of view, this may seem like a strange header to require. It’s re‐
            quired because an HTTP server can host any number of domains on a single IP address.
            This feature is called “name-based virtual hosting,” and it saves someone who owns
            multiple domain names from having to buy a separate computer and/or network card
            for each one.

        If-Match
            Type: Request header.
            Importance: High.
            This header is best described in terms of other headers. It’s used like If-UnmodifiedSince (described later),
            to make HTTP actions other than GET conditional—generally
            to avoid the lost update problem I mentioned in Chapter 11. But where If-UnmodifiedSince takes a time as its
            value, this header takes an ETag as its value.
            Tersely, this header is to If-None-Match and ETag as If-Unmodified-Since is to IfModified-Since and Last-Modified.

        If-Modified-Since
            Type: Request header.
            Importance: Very high.
            This request header is the backbone of conditional HTTP GET. Its value is a value the
            client found in the Last-Modified response header when it made a previous GET re‐
            quest to this resource. When the client sends that value as If-Modified-Since, it’s
            asking to get a representation only if the representation has changed since the last re‐
            quest.
            If the representation has in fact changed since that last request, its new LastModified date is more recent
            than the previous one. That means that the condition IfModified-Since is met, and the server sends the new
            representation. If the resource has not changed, the Last-Modified date is the same as it was, and the
            condition IfModified-Since fails. The server sends a response code of 304 (Not Modified) and no
            entity-body. That is, conditional HTTP GET succeeds if this condition fails.
            Since Last-Modified is only accurate to within one second, conditional HTTP GET
            can occasionally give the wrong result if it relies only on If-Modified-Since. This is
            the main reason why we also use ETag and If-None-Match.

        If-None-Match
            Type: Request header.
            Importance: Very high.
            This header is also used in conditional HTTP GET. Its value is taken from the ETag
            response header sent with a previous GET request.
            If the representation’s ETag has changed since that last request, the condition If-NoneMatch succeeds and the
            server sends the new representation. If the ETag is the same as
            before, the condition fails, and the server sends a response code of 304 (“Not Modified”)
            with no entity-body

        If-Unmodified-Since
            Type: Request header.
            Importance: Medium.
            Normally a client uses the value of the response header Last-Modified as the value of
            the request header If-Modified-Since to perform a conditional GET request. This
            header also takes the value of Last-Modified, but it’s usually used for making HTTP
            actions other than GET into conditional actions. The goal is usually to avoid the lost
            update problem I discussed in Chapter 11.
            If you make your PUT or PATCH request conditional on If-Unmodified-Since, then
            if someone else has changed the resource without your knowledge, your request will
            always get a response code of 412 (Precondition Failed). You can refetch the repre‐
            sentation and decide what to do with the new version that someone else modified.

        Last-Modified
            Type: Response header.
            Importance: Very high.
            This header makes conditional HTTP GET possible. It tells the client the last time the
            representation changed. The client can keep track of this date and use it in the IfModified-Since header of a
            future request.
            In web applications, Last-Modified is usually the current time, which makes condi‐
            tional HTTP GET useless. APIs should try to do better, since API clients often bombard
            their servers with requests for the same URLs (especially the billboard URL) over and
            over again

        Link
            Type: Request and response header.
            Defined in: RFC 5988.
            This header serves as a general-purpose hypermedia link. I cover this header many times
            in the book, notably in Chapter 4 and Chapter 11. Its value is a URL, in angle brackets,
            and then some parameters (like rel) that give context to the URL. For example:
                Link: <http://www.example.com/story/part2>; rel="next"

        Location
            Type: Response header.
            Importance: Very high.
            This is one of two HTTP headers defined in RFC 2616 that act as hypermedia links. The
            other one, Content-Location, has a simple, consistent meaning, but the meaning of a
            Location link depends on the status code.
            This header is strongly associated with the 3xx (Redirection) family of status codes,
            and much of the confusion surrounding HTTP redirects has to do with the fact that
            Location has a slightly different meaning for each type of redirect

        Set-Cookie
            Type: Response header.
            Importance: High on the World Wide Web, low for APIs.
            Defined in: RFC 2106.
            This is an attempt on the server’s part to set some semipersistent state in a cookie on
            the client side. The client is supposed to send an appropriate Cookie header with all
            future requests, until the cookie’s expiration date. The client may ignore this header (and
            that’s often a good idea), but there’s no guarantee that future requests will get a good
            response unless they provide the Cookie header. This violates the principle of stateless‐
            ness, which is why I don’t recommend using cookies in API

        User-Agent
            Type: Request header.
            Importance: High.
            This header lets the server know what kind of software is making the HTTP request.
            On the human web, this is a string that identifies the brand of web browser. In the world
            of APIs, it usually identifies the HTTP library or client library that was used to write
            the client. It may identify a specific client program instead.
            Soon after the Web became popular, servers started sniffing User-Agent to determine
            what kind of browser was on the other end. They then sent different representations
            based on the value of User-Agent. This is a terrible idea. Not only does User-Agent
            sniffing perpetuate incompatibilities between web browsers, it’s led to an arms race
            inside the User-Agent header itself.
            Almost every browser these days pretends to be Mozilla, because that was the internal
            code name of the first web browser to become popular (Netscape Navigator). A browser
            that doesn’t pretend to be Mozilla may not get the representation it needs. Some pretend
            to be both Mozilla and Internet Explorer, so they can trigger code originally intended
            only to be run on Internet Explorer. A few browsers even allow the user to select the
            User-Agent for every request, to trick servers into sending the right representations. It’s
            a huge mess.
!!!!        Don’t let history repeat itself. An API should only use User-Agent to gather statistics
            and to deny access to poorly programmed clients. It should not use User-Agent to tailor
            its representations to specific clients

        WWW-Authenticate
            Type: Response header.
            Importance: Very high.
            This header accompanies a response code of 401 (Unauthorized). It’s the server’s de‐
            mand that the client send some authentication next time it requests the URI. It also tells
            the client what kind of authentication the server expects. This will probably be HTTP
            Basic Auth, or some version of OAuth


An API Designer’s Guide to the Fielding Dissertation
(this is nice to have...you can return to this when you actually need to know more on the subject)

TODO Add a readme with the most important notes from each chapter..

TODO Create app that exposes application/vnd.collection+json as explained in the app/standard
TODO Also you could play with various http codes and headers


https://schema.org/docs/schemas.html






Improving LinkedIn profile

1 Title must say what we do.
    Done This is mentioned in every position that you have
2 LinkedIn should be the summary of the resume.
3 Three bullet points for every position ( what you do, a summary of the main project, the technology used ) don't use fluff words
    3 4 sentences max for eavh bullet
4 Drop generic terms (like software engineer/ developer instead use the tech like React/ Angular developer )
5 Good headshot
    DONE
6 Short bio in 2-3 bullet points. The bio should include total experience, technology and roles you are targeting.
7 Put in the title what you are going to get called for.
8 FEATUREd SECTION: The most valuable piece of real estate you have
      most important part of your profile..
        TODO ? You can put the CV here...or github link
9 Keep your strengths on LinkedIn, not the weaknesses.
10 Followers count DO NOT MATTER.
11 Show quantitative improvements you made, your people skills. People like working with chill people.
12 Job description is what you achieved not what you did.
13 Skills and endorsements are not very important.
14 Recommendations are very important.
    TODO See who could give you a recommandation...think about/contact ex colleagues
15 Technology used: Put full stack front to back.

16. Write your profile taking into consideration that it will be read by non-technical people (recruiters etc) !!!

17. Tell me (the recruiter) why you and not somebody else
TODO Ex of good about you: Highly motivated full stack JS developer seeking an entry-level oportunityin utilizing react and nodejs for
software engineering role. skilled in javascript react webdesign and customer engagement

"Impacted year over year growth by X"
"Shorted Sfotware development lifecycle by X"
"Established relationship with customer by doing Z"

Anyone can write a summary like : "I am a delveloper. I review requirements, write code" ...But that doesn;t stand out..

https://github.com/forgedhallpass/github-metrics
    you can see how to add such a readme on your profile....from what i read you need to create a github repo with the same
    name as the name of your account...but you can dig deeper..

About writing email to recruiters of a company:
    - even if the recruiter or the interviews pass you, they still know other people that might have an appropiate job for you





















































































































































































































































